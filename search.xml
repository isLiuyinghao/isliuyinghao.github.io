<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Rust 进阶：泛型</title>
    <url>/2024/08/29/Rust%20-%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>作为一个any工程师，不得不，必须必了解泛型这个概念。当然<code>Rust</code>中也有泛型。</p>
<h2 id="为什么要有泛型？"><a href="#为什么要有泛型？" class="headerlink" title="为什么要有泛型？"></a>为什么要有泛型？</h2><p>我们在编程中，经常有这样的需求：用同一功能的函数处理不同类型的数据，例如两个数的加法，无论是整数还是浮点数，甚至是自定义类型，都能进行支持。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add_i8</span>(a:<span class="type">i8</span>, b:<span class="type">i8</span>) <span class="punctuation">-&gt;</span> <span class="type">i8</span> &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_i32</span>(a:<span class="type">i32</span>, b:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_f64</span>(a:<span class="type">f64</span>, b:<span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add i8: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add_i8</span>(<span class="number">2i8</span>, <span class="number">3i8</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add i32: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add_i32</span>(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add f64: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add_f64</span>(<span class="number">1.23</span>, <span class="number">1.23</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写也太啰嗦了，明明核心逻辑一样，我们却要为了返回值去声明这么多冗余的方法，如果有了泛型我们可以这样：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Add; <span class="comment">// 引入 Add trait</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>&lt;T&gt;(a: T, b: T) <span class="punctuation">-&gt;</span> T</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Add&lt;Output = T&gt;, <span class="comment">// 确保 T 实现了 Add trait</span></span><br><span class="line">&#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add i8: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add</span>(<span class="number">2i8</span>, <span class="number">3i8</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add i32: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add</span>(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add f64: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add</span>(<span class="number">1.23</span>, <span class="number">1.23</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>更多例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">larget</span>&lt;T: std::cmp::<span class="built_in">PartialOrd</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = &amp;list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_list</span> = <span class="built_in">vec!</span>[<span class="number">34</span>,<span class="number">50</span>,<span class="number">25</span>,<span class="number">100</span>,<span class="number">65</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="title function_ invoke__">larget</span>(&amp;number_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;larget: &#123;&#125;&quot;</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结构体中使用泛型"><a href="#结构体中使用泛型" class="headerlink" title="结构体中使用泛型"></a>结构体中使用泛型</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">integer</span> = Point &#123; x: <span class="number">5</span>, y :<span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">float</span> = Point &#123; x: <span class="number">5.0</span>, y :<span class="number">10.1</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>除了结构体中的泛型参数，我们还能在该结构体的方法中定义额外的泛型参数，就跟泛型函数一样：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T, U&gt; Point&lt;T, U&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">mixup</span>&lt;V, W&gt;(<span class="keyword">self</span>, other: Point&lt;V, W&gt;) <span class="punctuation">-&gt;</span> Point&lt;T, W&gt; &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x,</span><br><span class="line">            y: other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10.4</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = Point &#123; x: <span class="string">&quot;Hello&quot;</span>, y: <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p3</span> = p1.<span class="title function_ invoke__">mixup</span>(p2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p3.x = &#123;&#125;, p3.y = &#123;&#125;&quot;</span>, p3.x, p3.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="const-泛型"><a href="#const-泛型" class="headerlink" title="const 泛型"></a>const 泛型</h2><p>先举个例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(&amp;arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">2</span>] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(&amp;arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单，只要使用数组切片，然后传入 arr 的不可变引用即可。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">display_array</span>(arr: &amp;[<span class="type">i32</span>]) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，将 i32 改成所有类型的数组：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">display_array</span>&lt;T: std::fmt::<span class="built_in">Debug</span>&gt;(arr: &amp;[T]) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(&amp;arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">2</span>] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(&amp;arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过引用，我们可以很轻松的解决处理任何类型数组的问题，但是如果在某些场景下引用不适宜用或者干脆不能用呢？</p>
<p>那就需要const 泛型出场了：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">display_array</span>&lt;T: std::fmt::<span class="built_in">Debug</span>, <span class="keyword">const</span> N: <span class="type">usize</span>&gt;(arr: [T; N]) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">2</span>] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Rust学习笔记</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust 进阶：生命周期</title>
    <url>/2024/11/11/Rust%20-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>生命周期，简而言之就是引用的有效作用域。在大多数时候，我们无需手动的声明生命周期，因为编译器可以自动进行推导，用类型来类比下：</p>
<ul>
<li>就像编译器大部分时候可以自动推导类型 &lt;-&gt; 一样，编译器大多数时候也可以自动推导生命周期</li>
<li>在多种类型存在时，编译器往往要求我们手动标明类型 &lt;-&gt; 当多个生命周期存在，且编译器无法推导出某个引用的生命周期时，就需要我们手动标明生命周期</li>
</ul>
<h2 id="解决啥问题？"><a href="#解决啥问题？" class="headerlink" title="解决啥问题？"></a>解决啥问题？</h2><p>生命周期是 Rust 用来标记引用有效范围的机制，确保数据不会在引用它之前就被销毁，从而避免了悬空引用的问题。</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>基本生命周期</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">42</span>;</span><br><span class="line">        r = &amp;x; <span class="comment">// 错误：&#x27;x&#x27; 的生命周期比 &#x27;r&#x27; 短</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, r); <span class="comment">// 编译错误：r 引用的变量 x 已经不再有效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，r 试图引用 x，但是 x 的生命周期在它所在的块内，当块结束时，x 就会被销毁，导致 r 成为悬空引用，Rust 编译器会报错。</p>
<h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><ul>
<li>fn  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">example</span>&lt;<span class="symbol">&#x27;a</span>&gt;(input: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    input</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>struc  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Example</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp; <span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>enum  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">StringOption</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>)</span><br><span class="line">    <span class="literal">None</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>&#39;a</code> 是生命周期参数，它指示入参和返回值的生命周期应该是相同的</li>
<li><code>&#39;a</code> 必须在函数的签名中进行标注，以告知编译器这引用的生命周期是相同的。<br>这个写法有些类似我们之前学的泛型…but：区别在<code>&lt;&#39;a&#39;&gt;</code>and <code>&lt;a&gt;</code> 一个单引号的问题。</li>
</ul>
<h2 id="生命周期省略规则"><a href="#生命周期省略规则" class="headerlink" title="生命周期省略规则"></a>生命周期省略规则</h2><p>Rust 中有一些生命周期省略规则，编译器可以在很多情况下自动推断生命周期，而不需要显式标注。</p>
<ol>
<li>如果函数有一个输入引用参数，且返回的是该引用，Rust 可以推断生命周期。</li>
<li>如果函数有多个引用参数，并且返回的是其中一个引用，Rust 也可以推断返回值的生命周期。<br>示例：省略生命周期标注<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;s[..] <span class="comment">// 返回整个字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在这个函数中，编译器可以推断 s 和返回值的生命周期是相同的，因此无需显式标注生命周期。</li>
</ol>
<h2 id="生命周期消除"><a href="#生命周期消除" class="headerlink" title="生命周期消除"></a>生命周期消除</h2><blockquote>
<p>rust 编译器自动推理，无需手动重复添加</p>
</blockquote>
<ol>
<li>每个引用参数都有自己的生命周期参数</li>
<li>如果只有一个输入引用参数，那么他的生命周期会被赋予所有输出引用</li>
<li>如果有多个输入生命周期参数，但其中一个是 <code>&amp;self</code> 或 <code>&amp;mut self</code>, 那么 <code>self</code> 的生命周期会被赋予所有输出引用</li>
</ol>
]]></content>
      <categories>
        <category>Rust学习笔记</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust 进阶：Macro 宏编程</title>
    <url>/2024/11/17/Rust-Macro%20%E5%AE%8F/</url>
    <content><![CDATA[<h1 id="Macro-宏编程"><a href="#Macro-宏编程" class="headerlink" title="Macro 宏编程"></a>Macro 宏编程</h1><p>在编程世界可以说是谈“宏”色变，原因在于 C 语言中的宏是非常危险的东东，但并不是所有语言都像 C 这样，例如对于古老的语言 Lisp 来说，宏就是就是一个非常强大的好帮手。</p>
<p>那话说回来，在 Rust 中宏到底是好是坏呢？本章将带你揭开它的神秘面纱。</p>
<p>Rust 中宏分为两大类：声明式宏 和 过程宏。</p>
<h2 id="声明式宏"><a href="#声明式宏" class="headerlink" title="声明式宏"></a>声明式宏</h2><p>声明式宏通过模式匹配来根据输入生成代码。它们通常使用 macro_rules! 来定义。这类宏通过指定模式来匹配输入并生成代码。</p>
<h3 id="定义和使用一个简单的宏"><a href="#定义和使用一个简单的宏" class="headerlink" title="定义和使用一个简单的宏"></a>定义和使用一个简单的宏</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> say_hello &#123;</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    say_hello!();  <span class="comment">// 调用宏，输出 &quot;Hello, world!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用参数的宏"><a href="#使用参数的宏" class="headerlink" title="使用参数的宏"></a>使用参数的宏</h3><p>你还可以在宏中使用参数，根据输入生成不同的代码。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> add &#123;</span><br><span class="line">    ($x:expr, $y:expr) =&gt; &#123;</span><br><span class="line">        $x + $y</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = add!(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The result is: &#123;&#125;&quot;</span>, result);  <span class="comment">// 输出 &quot;The result is: 5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p>宏支持更多复杂的模式匹配。例如，可以根据参数的类型或数量生成不同的代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> print_tuple &#123;</span><br><span class="line">    ($x:expr, $y:expr) =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Tuple: (&#123;&#125;, &#123;&#125;)&quot;</span>, $x, $y);</span><br><span class="line">    &#125;;</span><br><span class="line">    ($x:expr, $y:expr, $z:expr) =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Tuple: (&#123;&#125;, &#123;&#125;, &#123;&#125;)&quot;</span>, $x, $y, $z);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    print_tuple!(<span class="number">1</span>, <span class="number">2</span>);      <span class="comment">// 输出 &quot;Tuple: (1, 2)&quot;</span></span><br><span class="line">    print_tuple!(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);   <span class="comment">// 输出 &quot;Tuple: (1, 2, 3)&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="过程宏"><a href="#过程宏" class="headerlink" title="过程宏"></a>过程宏</h2><p>过程宏（也叫函数式宏）与声明式宏不同，它们允许你操作 Rust 代码的抽象语法树（<code>AST</code>）。过程宏需要定义为函数，通常通过 <code>#[derive]</code> 或 <code>#[proc_macro]</code> 属性来使用。</p>
<ul>
<li>派生宏（Derive Macros）</li>
<li>属性宏（Attribute Macros）</li>
<li>函数宏（Function-like Macro）</li>
</ul>
<h3 id="派生宏（Derive-Macros）"><a href="#派生宏（Derive-Macros）" class="headerlink" title="派生宏（Derive Macros）"></a>派生宏（Derive Macros）</h3><p>派生宏允许你通过添加 <code>#[derive]</code> 属性来自动生成一些常见代码（如实现 <code>Debug</code>、<code>Default</code>、<code>Clone</code>、<code>Copy</code>、<code>Serialize</code> 等）。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Default, Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">person</span> = Person &#123;</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Alice&quot;</span>),</span><br><span class="line">        age: <span class="number">30</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, person);  <span class="comment">// 自动生成的 Debug 输出：Person &#123; name: &quot;Alice&quot;, age: 30 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="属性宏（Attribute-Macros）"><a href="#属性宏（Attribute-Macros）" class="headerlink" title="属性宏（Attribute Macros）"></a>属性宏（Attribute Macros）</h3><p>属性宏允许你为函数、结构体或其他项目添加新的属性行为。</p>
<h3 id="函数宏（Function-like-Macro）"><a href="#函数宏（Function-like-Macro）" class="headerlink" title="函数宏（Function-like Macro）"></a>函数宏（Function-like Macro）</h3><p>这类宏需要实现一个过程宏函数，它们能够读取 Rust 代码的抽象语法树（AST），并生成新的代码。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[route(GET, <span class="string">&quot;/&quot;</span>)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">index</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[proc_macro_attribute]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">route</span>(attr: TokenStream, item: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过程宏的实现通常会用到 syn 和 quote 库</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">syn</span> = <span class="string">&quot;1.0&quot;</span></span><br><span class="line"><span class="attr">quote</span> = <span class="string">&quot;1.0&quot;</span></span><br><span class="line"><span class="attr">proc-macro2</span> = <span class="string">&quot;1.0&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> proc_macro;</span><br><span class="line"><span class="keyword">use</span> proc_macro::TokenStream;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[proc_macro]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">my_macro</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    <span class="comment">// 输入：Rust 代码的 AST</span></span><br><span class="line">    <span class="comment">// 生成：新的 Rust 代码</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">generated_code</span> = quote::quote! &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">generated_function</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;This function was generated by a macro!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    generated_code.<span class="title function_ invoke__">into</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>创建声明宏: 使用<code>macro_rules!</code>定义宏，通过横式匹配生成代码</li>
<li>创建过程宏: 使用过程宏函数<code>〔#[prac_nacro])</code>、派生宏<code>（#[proc_macro_derive])</code>和属性宏<code>〔 w[proc_macro_attribute]）</code>生成代码</li>
</ul>
<h3 id="宏的应用场景"><a href="#宏的应用场景" class="headerlink" title="宏的应用场景"></a>宏的应用场景</h3><ol>
<li>减少重复代码: 通过宏生成重复的代码</li>
<li>编译期计算: 在编译期进行计算并生成代码，提高运行时性能</li>
<li>DSL(领域特定语言)︰使用宏定义领域特定语言，提高代码的表达力和可读性</li>
</ol>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>通过macro_rules!实现对应的macro,并通过测试case</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(repeat!(<span class="string">&quot;×&quot;</span>,<span class="number">3</span>),<span class="string">&quot;xxx&quot;</span>)&#x27;;</span><br><span class="line"><span class="built_in">assert_eq!</span>(sum!(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>), <span class="number">15</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(max_value!(<span class="number">1</span>,<span class="number">8</span>,<span class="number">9</span>),<span class="number">9</span>);</span><br></pre></td></tr></table></figure>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 宏定义</span></span><br><span class="line"><span class="built_in">macro_rules!</span> repeat &#123;</span><br><span class="line">    ($<span class="type">str</span>:expr, $times:expr) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..$times &#123;</span><br><span class="line">                result.<span class="title function_ invoke__">push_str</span>($<span class="type">str</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">macro_rules!</span> sum &#123;</span><br><span class="line">    ( $($val:expr),* ) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span> = <span class="number">0</span>;</span><br><span class="line">            $( result += $val; )*</span><br><span class="line">            result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">macro_rules!</span> max_value &#123;</span><br><span class="line">    ( $($val:expr),* ) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">max</span> = <span class="type">i32</span>::MIN;  <span class="comment">// 使用 i32 类型的最小值</span></span><br><span class="line">            $(</span><br><span class="line">                <span class="keyword">if</span> $val &gt; max &#123;</span><br><span class="line">                    max = $val;</span><br><span class="line">                &#125;</span><br><span class="line">            )*</span><br><span class="line">            max</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">test_repeat_macro</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(repeat!(<span class="string">&quot;×&quot;</span>, <span class="number">3</span>), <span class="string">&quot;×××&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">test_sum_macro</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(sum!(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>), <span class="number">15</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">test_max_value_macro</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(max_value!(<span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>), <span class="number">9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 这是程序的入口，可以在这里运行一些示例代码或应用逻辑</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Rust学习笔记</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust-不可变引用vs可变引用</title>
    <url>/2024/09/17/Rust-%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8vs%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h1 id="引用与借用"><a href="#引用与借用" class="headerlink" title="引用与借用"></a>引用与借用</h1><p>Rust 通过 借用(Borrowing) 这个概念来达成上述的目的，获取变量的引用，称之为借用(borrowing)。正如现实生活中，如果一个人拥有某样东西，你可以从他那里借来，当使用完毕后，也必须要物归原主。</p>
<h2 id="引用与解引用"><a href="#引用与解引用" class="headerlink" title="引用与解引用"></a>引用与解引用</h2><p>常规引用是一个指针类型，指向了对象存储的内存地址。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们创建一个 i32 值的引用 y，然后使用解引用运算符来解出 y 所使用的值</p>
<ul>
<li>变量 <code>x</code> 存放了一个 <code>i32</code> 值 <code>5</code>。</li>
<li><code>y</code> 是 <code>x</code> 的一个引用。可以断言 <code>x</code> 等于 <code>5</code>。</li>
<li>对 <code>y</code> 的值做出断言，必须使用 <code>*y</code> 来解出引用所指向的值（也就是<code>解引用</code>）。</li>
<li>一旦解引用了 <code>y</code>，就可以访问 <code>y</code> 所指向的整型值并可以与 <code>5</code> 做比较。</li>
<li>当然 <code>assert_eq!(5, y);</code>是不行的：<ul>
<li>不允许比较整数与引用，因为它们是不同的类型。</li>
</ul>
</li>
</ul>
<h2 id="不可变引用"><a href="#不可变引用" class="headerlink" title="不可变引用"></a>不可变引用</h2><p>先举个例子</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ps: <code>&amp;</code> 符号即是引用，它们允许你使用值，但是不获取所有权<br>通过 <code>&amp;s1</code> 语法，我们创建了一个指向 <code>s1</code> 的引用，但是并不拥有它。当引用离开作用域后，其指向的值也不会被丢弃。<br>如果我们想直接修改 <code>s1</code>的值这里会报错。</p>
</blockquote>
<h2 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a>可变引用</h2><p>既然我们想要修改s1的值，那就需要付出代价</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>声明 s 是可变类型</li>
<li>创建一个可变的引用 &amp;mut s </li>
<li>接受可变引用参数 some_string: &amp;mut String 的函数</li>
</ol>
<h3 id="可变引用同时只能存在一个"><a href="#可变引用同时只能存在一个" class="headerlink" title="可变引用同时只能存在一个"></a>可变引用同时只能存在一个</h3><blockquote>
<p>不过可变引用并不是随心所欲、想用就用的，它有一个很大的限制： 同一作用域，特定数据只能有一个可变引用</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, r1, r2);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上代码会报错</p>
<h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>使 Rust 在编译期就避免数据竞争，数据竞争可由以下行为造成：</p>
<ul>
<li>两个或更多的指针同时访问同一数据</li>
<li>至少有一个指针被用来写入数据</li>
<li>没有同步数据访问的机制</li>
</ul>
<h3 id="可变引用与不可变引用不能同时存在"><a href="#可变引用与不可变引用不能同时存在" class="headerlink" title="可变引用与不可变引用不能同时存在"></a>可变引用与不可变引用不能同时存在</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// 大问题</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;</span>, r1, r2, r3);</span><br></pre></td></tr></table></figure>
<p>以上代码会报错</p>
<h4 id="好处-1"><a href="#好处-1" class="headerlink" title="好处"></a>好处</h4><p>其实这个也很好理解，正在借用不可变引用的用户，肯定不希望他借用的东西，被另外一个人莫名其妙改变了。多个不可变借用被允许是因为没有人会去试图修改数据，每个人都只读这一份数据而不做修改，因此不用担心数据被污染。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>同一时刻，你只能拥有要么一个可变引用, 要么任意多个不可变引用</li>
<li>引用必须总是有效的</li>
</ul>
]]></content>
      <categories>
        <category>Rust学习笔记</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust-函数</title>
    <url>/2024/08/25/Rust-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="Rust-函数"><a href="#Rust-函数" class="headerlink" title="Rust 函数"></a>Rust 函数</h1><p>在 Rust 中，函数是一种重要的概念，它们具有严格的类型系统和内存安全性。</p>
<h2 id="定义一个函数"><a href="#定义一个函数" class="headerlink" title="定义一个函数"></a>定义一个函数</h2><p>在 Rust 中，函数的定义使用 fn 关键字，后跟函数名、参数列表、返回类型和函数体。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">fn greet() &#123;</span><br><span class="line">    println!(&quot;Hello, Rust!&quot;)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    greet()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>在 Rust 编程语言中，函数参数用于在函数调用时向函数传递数据。每个参数都需要指定类型，并且参数在函数体内是不可变的，除非显式地使用 mut 关键字将其声明为可变参数。</p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子 1"></a>例子 1</h3><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">fn add(a: i32, b: i32) -&gt; i32 &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let <span class="attr">result</span> = add(<span class="number">5</span>, <span class="number">3</span>)<span class="comment">;</span></span><br><span class="line">    println!(&quot;The sum is: &#123;&#125;&quot;, result)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子 2"></a>例子 2</h3><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">fn print_message(message: &amp;str) &#123;</span><br><span class="line">    println!(&quot;Message: &#123;&#125;&quot;, message)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn increment(mut value: i32) -&gt; i32 &#123;</span><br><span class="line">    value += 1<span class="comment">;</span></span><br><span class="line">    value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let <span class="attr">msg</span> = <span class="string">&quot;Hello, Rust!&quot;</span><span class="comment">;</span></span><br><span class="line">    print_message(msg)<span class="comment">; // 调用时传递不可变引用</span></span><br><span class="line"></span><br><span class="line">    let <span class="attr">number</span> = <span class="number">10</span><span class="comment">;</span></span><br><span class="line">    let <span class="attr">incremented_number</span> = increment(number)<span class="comment">; // 调用时传递不可变变量</span></span><br><span class="line">    println!(&quot;Incremented number: &#123;&#125;&quot;, incremented_number)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><p>函数可以返回一个值，返回值是函数的输出结果，用于提供函数执行后的结果或计算的值。在 Rust 中，函数的返回类型由-&gt;符号后跟类型来指定。</p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">fn add(a: i32, b: i32) -&gt; i32 &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let <span class="attr">result</span> = add(<span class="number">3</span>, <span class="number">5</span>)<span class="comment">;</span></span><br><span class="line">    println!(&quot;Result: &#123;&#125;&quot;, result)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义了一个名为 add 的函数，它接收两个参数 a 和 b，类型均为 i32。函数体中的表达式 a + b 表示将参数 a 和 b 相加，并作为函数的返回值。</p>
<p>在 main 函数中，我们调用了 add 函数，并将返回值存储在 result 变量中。然后，我们使用 println!宏打印出结果。</p>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>Rust 不支持传统意义上的函数重载，即在同一作用域中定义多个同名函数但参数类型或数量不同的情况。然而，Rust 通过使用泛型和 trait 来实现类似的功能。</p>
<p>以下是一个使用泛型和 trait 实现函数重载的示例：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">trait Add &#123;</span><br><span class="line">    type Output<span class="comment">;</span></span><br><span class="line">    fn add(self, other: Self) -&gt; Self::Output<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Add for i32 &#123;</span><br><span class="line">    type <span class="attr">Output</span> = i32<span class="comment">;</span></span><br><span class="line">    fn add(self, other: Self) -&gt; Self::Output &#123;</span><br><span class="line">        self + other</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Add for f64 &#123;</span><br><span class="line">    type <span class="attr">Output</span> = f64<span class="comment">;</span></span><br><span class="line">    fn add(self, other: Self) -&gt; Self::Output &#123;</span><br><span class="line">        self + other</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let <span class="attr">a</span> = <span class="number">3</span><span class="comment">;</span></span><br><span class="line">    let <span class="attr">b</span> = <span class="number">5</span><span class="comment">;</span></span><br><span class="line">    let <span class="attr">c</span> = <span class="number">2.5</span><span class="comment">;</span></span><br><span class="line">    let <span class="attr">d</span> = <span class="number">4.8</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    let <span class="attr">result1</span> = a.add(b)<span class="comment">;</span></span><br><span class="line">    let <span class="attr">result2</span> = c.add(d)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    println!(&quot;Result 1: &#123;&#125;&quot;, result1)<span class="comment">;</span></span><br><span class="line">    println!(&quot;Result 2: &#123;&#125;&quot;, result2)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了一个名为 Add 的 trait，它具有一个关联类型 Output 和一个 add 方法。然后，我们为 i32 和 f64 类型分别实现了 Add trait，为它们提供了不同的实现方式。</p>
<p>在 main 函数中，我们分别定义了 a、b、c 和 d 四个变量，并使用 add 方法对它们进行相加操作。根据变量的类型，编译器会自动选择正确的实现方式。</p>
<h2 id="函数作为参数和返回值"><a href="#函数作为参数和返回值" class="headerlink" title="函数作为参数和返回值"></a>函数作为参数和返回值</h2><p>在 Rust 中，函数可以作为参数传递给其他函数，也可以作为函数的返回值。这种特性可以实现函数的灵活组合和高阶函数的编写。</p>
<p>以下是一个函数作为参数和返回值的示例：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">fn add(a: i32, b: i32) -&gt; i32 &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn subtract(a: i32, b: i32) -&gt; i32 &#123;</span><br><span class="line">    a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn calculate(op: fn(i32, i32) -&gt; i32, a: i32, b: i32) -&gt; i32 &#123;</span><br><span class="line">    op(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let <span class="attr">result1</span> = calculate(add, <span class="number">3</span>, <span class="number">5</span>)<span class="comment">;</span></span><br><span class="line">    let <span class="attr">result2</span> = calculate(subtract, <span class="number">8</span>, <span class="number">4</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    println!(&quot;Result 1: &#123;&#125;&quot;, result1)<span class="comment">;</span></span><br><span class="line">    println!(&quot;Result 2: &#123;&#125;&quot;, result2)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Rust学习笔记</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust-变量绑定+解构</title>
    <url>/2024/09/17/Rust-%E5%8F%98%E9%87%8F%E7%BB%91%E5%AE%9A+%E8%A7%A3%E6%9E%84/</url>
    <content><![CDATA[<h1 id="为何要手动设置变量的可变性？"><a href="#为何要手动设置变量的可变性？" class="headerlink" title="为何要手动设置变量的可变性？"></a>为何要手动设置变量的可变性？</h1><p>在其它大多数语言中:</p>
<ul>
<li>要么只支持声明可变的变量<ul>
<li>为编程提供了灵活性</li>
</ul>
</li>
<li>要么只支持声明不可变的变量<ul>
<li>为编程提供了安全性<br>什么？鱼和熊掌不可兼得？Rust：小孩子才做选择，我选择了两者我都要，既要灵活性又要安全性！</li>
</ul>
</li>
</ul>
<p>当然除了以上两个优点，还有一个很大的优点，那就是运行性能上的提升，因为将本身无需改变的变量声明为不可变在运行期会避免一些多余的 runtime 检查。</p>
<p>说白了就是：</p>
<ul>
<li>灵活性</li>
<li>安全性</li>
<li>运行性能</li>
</ul>
<h2 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h2><blockquote>
<p>Rust 语言有一些关键字（keywords），和其他语言一样，这些关键字都是被保留给 Rust 语言使用的，因此，它们不能被用作变量或函数的名称。在<a href="https://course.rs/appendix/keywords.html">附录 A</a>中可找到关键字列表。</p>
</blockquote>
<h2 id="变量可变性"><a href="#变量可变性" class="headerlink" title="变量可变性"></a>变量可变性</h2><p>Rust 的变量在默认情况下是<b>不可变</b>的。<br><br>当然你可以通过 mut 关键字让变量变为<b>可变</b>的，让设计更灵活。</p>
<h3 id="错误例子"><a href="#错误例子" class="headerlink" title="错误例子"></a>错误例子</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">    x = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会出现报错，具体的错误原因是 cannot assign twice to immutable variable x（无法对不可变的变量进行重复赋值），因为我们想为不可变的 x 变量再次赋值。</p>
<h3 id="正确的赋值"><a href="#正确的赋值" class="headerlink" title="正确的赋值"></a>正确的赋值</h3><p>为了让变量声明为可变,将 src&#x2F;main.rs 改为以下内容：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">    x = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选择可变还是不可变，更多的还是取决于你的使用场景，</p>
<ul>
<li>例如不可变可以带来安全性，但是丧失了灵活性和性能（如果你要改变，就要重新创建一个新的变量，这里涉及到内存对象的再分配）。</li>
<li>而可变变量最大的好处就是使用上的灵活性和性能上的提升。</li>
</ul>
<blockquote>
<p>ps: 如果我们在设计原型或刚刚开始一个项目时，建了一个变量却不在任何地方使用它。我们希望告诉 Rust 不要警告未使用的变量，为此可以用下划线作为变量名的开头</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_x</span> = <span class="number">5</span>; <span class="comment">// 这样就会忽略啦</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变量解构"><a href="#变量解构" class="headerlink" title="变量解构"></a>变量解构</h2><p>js 中就有变量解构方法，rust中也和js解构方法类似。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (a, <span class="keyword">mut</span> b): (<span class="type">bool</span>,<span class="type">bool</span>) = (<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// a = true,不可变; b = false，可变</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;:?&#125;, b = &#123;:?&#125;&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line">    b = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解构式赋值"><a href="#解构式赋值" class="headerlink" title="解构式赋值"></a>解构式赋值</h3><p>在 Rust 1.59 版本后，我们可以在赋值语句的左式中使用元组、切片和结构体模式了。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Struct</span> &#123;</span><br><span class="line">    e: <span class="type">i32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (a, b, c, d, e);</span><br><span class="line"></span><br><span class="line">    (a, b) = (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// _ 代表匹配一个值，但是我们不关心具体的值是什么，因此没有使用一个变量名而是使用了 _</span></span><br><span class="line">    [c, .., d, _] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    Struct &#123; e, .. &#125; = Struct &#123; e: <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>], [a, b, c, d, e]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种使用方式跟之前的 let 保持了一致性，但是 let 会重新绑定，而这里仅仅是对之前绑定的变量进行再赋值。</p>
<blockquote>
<p>ps: 需要注意的是，使用 +&#x3D; 的赋值语句还不支持解构式赋值。</p>
</blockquote>
<h2 id="变量vs常量"><a href="#变量vs常量" class="headerlink" title="变量vs常量"></a>变量vs常量</h2><table>
<thead>
<tr>
<th>特性</th>
<th>变量 (variable)</th>
<th>常量 (constant)</th>
</tr>
</thead>
<tbody><tr>
<td>关键字</td>
<td><code>let</code></td>
<td><code>const</code></td>
</tr>
<tr>
<td>可变性</td>
<td>默认不可变，允许使用 <code>mut</code></td>
<td>自始至终不可变，不允许使用 <code>mut</code></td>
</tr>
<tr>
<td>类型标注</td>
<td>可以省略，由编译器推断</td>
<td>必须标注类型</td>
</tr>
<tr>
<td>赋值时间</td>
<td>运行时确定</td>
<td>编译时确定</td>
</tr>
<tr>
<td>命名约定</td>
<td>以小写开头，遵循驼峰命名法</td>
<td>全部字母大写，使用下划线分隔单词</td>
</tr>
<tr>
<td>作用域</td>
<td>在作用域内有效，生命周期随作用域结束</td>
<td>在声明的作用域内有效，生命周期贯穿整个程序</td>
</tr>
<tr>
<td>示例</td>
<td><code>let mut points = 100;</code></td>
<td><code>const MAX_POINTS: u32 = 100_000;</code></td>
</tr>
<tr>
<td>适用场景</td>
<td>需要在程序运行中更改值的情况</td>
<td>需要共享并保持不变的值，例如常数或全局参数</td>
</tr>
</tbody></table>
<h2 id="变量遮蔽-shadowing"><a href="#变量遮蔽-shadowing" class="headerlink" title="变量遮蔽(shadowing)"></a>变量遮蔽(shadowing)</h2><p>Rust 允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的</p>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 在main函数的作用域内对之前的x进行遮蔽</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在当前的花括号作用域内，对之前的x进行遮蔽</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = x * <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The value of x in the inner scope is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><ol>
<li>将数值 5 绑定到 x</li>
<li>使用 let x &#x3D; 来遮蔽之前的 x（并+1），此时值为 <b>6</b></li>
<li>第三个 let 语句同样遮蔽前面的 x，取之前的值并乘上 2, 此时值为 <b>12</b><br>所以:</li>
<li>第一个输出的值是：12</li>
<li>第二个为：6</li>
</ol>
<h3 id="变量遮蔽的用处"><a href="#变量遮蔽的用处" class="headerlink" title="变量遮蔽的用处"></a>变量遮蔽的用处</h3><p>变量遮蔽的用处在于，如果你在某个作用域内无需再使用之前的变量（在被遮蔽后，无法再访问到之前的同名变量），就可以重复的使用变量名字，而不用绞尽脑汁去想更多的名字。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>假设有一个程序要统计一个空格字符串的空格数量：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">spaces</span> = <span class="string">&quot;   &quot;</span>;</span><br><span class="line"><span class="comment">// usize数值类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">spaces</span> = spaces.<span class="title function_ invoke__">len</span>();</span><br></pre></td></tr></table></figure>
<p>这种结构是允许的：</p>
<ul>
<li>第一个 spaces 变量是一个字符串类型</li>
<li>第二个 spaces 变量是一个全新的变量且和第一个具有相同的变量名，且是一个数值类型。</li>
</ul>
<p>所以变量遮蔽可以帮我们节省些脑细胞，不用去想如 spaces_str 和 spaces_num 此类的变量名</p>
]]></content>
      <categories>
        <category>Rust学习笔记</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust-基本类型</title>
    <url>/2024/09/17/Rust-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><p>当一门语言不谈类型时，你得小心，这大概率是动态语言(别拍我，我承认是废话)。但是把类型大张旗鼓的用多个章节去讲的，Rust 是其中之一。</p>
<blockquote>
<p>Rust 每个值都有其确切的数据类型，总的来说可以分为两类：基本类型和复合类型。 </p>
</blockquote>
<h2 id="基本类型-1"><a href="#基本类型-1" class="headerlink" title="基本类型"></a>基本类型</h2><p>基本类型: 意味着它们往往是一个最小化原子类型，无法解构为其它类型(一般意义上来说)，由以下组成：</p>
<ul>
<li>数值类型: <ul>
<li>有符号整数 (i8, i16, i32, i64, isize)</li>
<li>无符号整数 (u8, u16, u32, u64, usize) </li>
<li>浮点数 (f32, f64)、以及有理数、复数</li>
</ul>
</li>
<li>字符串：字符串字面量和字符串切片 &amp;str</li>
<li>布尔类型： true和false</li>
<li>字符类型: 表示单个 Unicode 字符，存储为 4 个字节</li>
<li>单元类型: 即 () ，其唯一的值也是 ()</li>
</ul>
<h3 id="数值类型（点击查看更多）"><a href="#数值类型（点击查看更多）" class="headerlink" title="数值类型（点击查看更多）"></a><a href="https://course.rs/basic/base-type/numbers.html">数值类型（点击查看更多）</a></h3><blockquote>
<p>Rust 使用一个相对传统的语法来创建整数（1，2，…）和浮点数（1.0，1.1，…）。整数、浮点数的运算和你在其它语言上见过的一致，都是通过常见的运算符来完成。</p>
</blockquote>
<h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><blockquote>
<p>ps: 整数是没有小数部分的数字。之前使用过的 i32 类型，表示有符号的 32 位整数（ i 是英文单词 integer 的首字母，与之相反的是 u，代表无符号 unsigned 类型）。</p>
</blockquote>
<p>下表显示了 Rust 中的内置的整数类型：</p>
<table>
<thead>
<tr>
<th>长度</th>
<th>有符号类型</th>
<th>无符号类型</th>
</tr>
</thead>
<tbody><tr>
<td>8 位</td>
<td>i8</td>
<td>u8</td>
</tr>
<tr>
<td>16 位</td>
<td>i16</td>
<td>u16</td>
</tr>
<tr>
<td>32 位</td>
<td>i32</td>
<td>u32</td>
</tr>
<tr>
<td>64 位</td>
<td>i64</td>
<td>u64</td>
</tr>
<tr>
<td>128 位</td>
<td>i128</td>
<td>u128</td>
</tr>
<tr>
<td>视架构而定</td>
<td>isize</td>
<td>usize</td>
</tr>
</tbody></table>
<p>整形字面量可以用下表的形式书写：</p>
<table>
<thead>
<tr>
<th>数字字面量</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>十进制</td>
<td>98_222</td>
</tr>
<tr>
<td>十六进制</td>
<td>0xff</td>
</tr>
<tr>
<td>八进制</td>
<td>0o77</td>
</tr>
<tr>
<td>二进制</td>
<td>0b1111_0000</td>
</tr>
<tr>
<td>字节 (仅限于 u8)</td>
<td>b’A’</td>
</tr>
</tbody></table>
<h4 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h4><p>浮点类型数字 是带有小数点的数字，在 Rust 中浮点类型数字也有两种基本类型：</p>
<ul>
<li>f32 </li>
<li>f64</li>
</ul>
<blockquote>
<p>默认浮点类型是 f64，在现代的 CPU 中它的速度与 f32 几乎相同，但精度更高。</p>
</blockquote>
<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p>数学上未定义的结果</p>
<blockquote>
<p>如对负数取平方根 -42.1.sqrt() ，会产生一个特殊的结果：Rust 的浮点数类型使用 NaN (not a number)来处理这些情况。</p>
</blockquote>
<p>可以使用 is_nan() 等方法，可以用来判断一个数值是否是 NaN </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = (-<span class="number">42.0_f32</span>).<span class="title function_ invoke__">sqrt</span>();</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">is_nan</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;未定义的数学行为&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符类型-char-不包含字符串哦"><a href="#字符类型-char-不包含字符串哦" class="headerlink" title="字符类型(char)(不包含字符串哦)"></a>字符类型(char)(不包含字符串哦)</h3><p>Rust 的字符不仅仅是 ASCII，所有的 Unicode 值都可以作为 Rust 字符，包括单个的中文、日文、韩文、emoji 表情符号等等，都是合法的字符类型。</p>
<blockquote>
<p>由于 Unicode 都是 4 个字节编码，因此字符类型也是占用 4 个字节：<br>例子：</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span> = <span class="string">&#x27;ℤ&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">g</span> = <span class="string">&#x27;国&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">heart_eyed_cat</span> = &#x27;😻&#x27;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;字符&#x27;中&#x27;占用了&#123;&#125;字节的内存大小&quot;</span>,std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling ...</span><br><span class="line">字符&#x27;中&#x27;占用了4字节的内存大小</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，我们还没开始讲字符串，但是这里提前说一下，和一些语言不同，Rust 的字符只能用 ‘’ 来表示， “” 是留给字符串的。</p>
</blockquote>
<h3 id="布尔-bool"><a href="#布尔-bool" class="headerlink" title="布尔(bool)"></a>布尔(bool)</h3><p>Rust 中的布尔类型有两个可能的值：true 和 false，布尔值占用内存的大小为 1 个字节</p>
<h3 id="单元类型"><a href="#单元类型" class="headerlink" title="单元类型"></a>单元类型</h3><p>单元类型就是 <code>()</code> ，对，你没看错，就是 <code>()</code> ，唯一的值也是 <code>()</code></p>
<p>只能说，再不起眼的东西，都有其用途，在目前为止的学习过程中，大家已经看到过很多次 fn main() 函数的使用吧？那么这个函数返回什么呢？</p>
<p>没错， main 函数就返回这个单元类型 ()，你不能说 main 函数无返回值，因为没有返回值的函数在 Rust 中是有单独的定义的：<b>发散函数( diverge function )，顾名思义，无法收敛的函数。</b></p>
<p>例如常见的 println!() 的返回值也是单元类型 ()。</p>
<p>再比如，你可以用 () 作为 map 的值，表示我们不关注具体的值，只关注 key。 这种用法和 Go 语言的 struct{} 类似，可以作为一个值用来占位，但是完全不占用任何内存。</p>
]]></content>
      <categories>
        <category>Rust学习笔记</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust-复合类型-元组</title>
    <url>/2024/09/25/Rust-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B-%E5%85%83%E7%BB%84/</url>
    <content><![CDATA[<h1 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组( Tuple )"></a>元组( Tuple )</h1><ul>
<li>在 Rust 中，<code>元组（Tuple</code>） 是一种将多个不同类型的值组合在一起的<strong>复合类型</strong>。</li>
<li>与数组不同，元组中的元素<strong>可以是不同的数据类型，并且元组的长度是固定的</strong>。</li>
<li>一旦定义了元组，其长度和包含的类型就不能改变。<blockquote>
<p>ps: 在 Rust 中，元组的长度是固定的，而且有一个限制，即元组的最大长度为 12 个元素。如果你定义的元组超出了这个长度限制，编译器会给出错误提示。</p>
</blockquote>
</li>
</ul>
<h2 id="元组的特点"><a href="#元组的特点" class="headerlink" title="元组的特点"></a>元组的特点</h2><ul>
<li>不同类型：元组中的元素可以是不同的类型。</li>
<li>固定长度：元组的长度在创建后是固定的，不能动态增加或减少元素。</li>
<li>索引访问：可以使用索引访问元组中的元素，索引从 0 开始。</li>
</ul>
<h3 id="不同类型"><a href="#不同类型" class="headerlink" title="不同类型"></a>不同类型</h3><p>元组中的元素可以是不同的类型。元组的类型签名是 (T1, T2, …), 这里 T1, T2 是相对应的元组成员的类型.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tuple</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">char</span>) = (<span class="number">42</span>, <span class="number">3.14</span>, <span class="string">&#x27;R&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="固定长度"><a href="#固定长度" class="headerlink" title="固定长度"></a>固定长度</h3><p>元组的长度在创建后是固定的，不能动态增加或减少元素，且 一旦定义了元组，其长度和包含的类型就不能改变</p>
<p>举个例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 定义一个三元素元组，包含 i32, f64, char 三种类型</span></span><br><span class="line">   <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">tuple</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">char</span>) = (<span class="number">42</span>, <span class="number">3.14</span>, <span class="string">&#x27;R&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义了 定义一个三元素元组，包含 i32, f64, char 三种类型；</p>
<p>尝试增加元素:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">tuple.<span class="number">3</span> = <span class="symbol">&#x27;new</span> element&#x27;</span><br></pre></td></tr></table></figure>
<p> 尝试重赋一个新的长度不同的元组</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">tuple = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>编译后：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> no field `3` on type `(i32, f64, char)`</span><br><span class="line"><span class="meta prompt_">  --&gt; </span><span class="language-bash">src/main.rs:10:11</span></span><br><span class="line">   |</span><br><span class="line">10 |     tuple.3 = &quot;new element&quot;;</span><br><span class="line">   |           ^ unknown field</span><br><span class="line"></span><br><span class="line">error[E0308]: mismatched types</span><br><span class="line"><span class="meta prompt_">  --&gt; </span><span class="language-bash">src/main.rs:11:17</span></span><br><span class="line">   |</span><br><span class="line">11 |     tuple = (1, 2, 3, 4);</span><br><span class="line">   |                 ^</span><br><span class="line">   |                 |</span><br><span class="line">   |                 expected `f64`, found integer</span><br><span class="line">   |                 help: use a float literal: `2.0`</span><br><span class="line"></span><br><span class="line">error[E0308]: mismatched types</span><br><span class="line"><span class="meta prompt_">  --&gt; </span><span class="language-bash">src/main.rs:11:20</span></span><br><span class="line">   |</span><br><span class="line">11 |     tuple = (1, 2, 3, 4);</span><br><span class="line">   |                    ^ expected `char`, found `u8`</span><br><span class="line"></span><br><span class="line">error[E0308]: mismatched types</span><br><span class="line"><span class="meta prompt_">  --&gt; </span><span class="language-bash">src/main.rs:11:13</span></span><br><span class="line">   |</span><br><span class="line">11 |     tuple = (1, 2, 3, 4);</span><br><span class="line">   |             ^^^^^^^^^^^^ expected a tuple with 3 elements, found one with 4 elements</span><br><span class="line">   |</span><br><span class="line">   = note: expected tuple `(i32, f64, char)`</span><br><span class="line">              found tuple `(i32, f64, char, &#123;integer&#125;)`</span><br><span class="line"></span><br><span class="line">Some errors have detailed explanations: E0308, E0609.</span><br><span class="line">For more information about an error, try `rustc --explain E0308`.</span><br><span class="line">error: could not compile `hello-rust` (bin &quot;hello-rust&quot;) due to 4 previous errors</span><br></pre></td></tr></table></figure>

<h3 id="索引访问"><a href="#索引访问" class="headerlink" title="索引访问"></a>索引访问</h3><p>可以使用索引来获取元组的成员</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = (<span class="string">&quot;i&quot;</span>, <span class="string">&quot;am&quot;</span>, <span class="string">&quot;sunface&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(t.<span class="number">2</span>, <span class="string">&quot;sunface&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用模式匹配解构元组"><a href="#用模式匹配解构元组" class="headerlink" title="用模式匹配解构元组"></a>用模式匹配解构元组</h3><p>当然除了用，索引访问外<code>模式匹配</code>也是可以进行访问的</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span> = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Rust学习笔记</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust-字符串与切片</title>
    <url>/2024/09/23/Rust-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E5%88%87%E7%89%87/</url>
    <content><![CDATA[<h1 id="复合类型-字符串与切片"><a href="#复合类型-字符串与切片" class="headerlink" title="复合类型 - 字符串与切片"></a>复合类型 - 字符串与切片</h1><h2 id="字符串与切片"><a href="#字符串与切片" class="headerlink" title="字符串与切片"></a>字符串与切片</h2><p>字符串在Rust中是一个很让人头疼的存在….不要怀疑真的就是这样</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串我们肯定不会陌生，在哪一个语言中我们都会使用到它。在之前我们也：我们提到过，<a href="https://isliuyinghao.github.io/2024/09/17/Rust-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/">Rust 中的字符是 Unicode 类型，因此每个字符占据 4 个字节内存空间，但是在字符串中不一样，字符串是 UTF-8 编码，也就是字符串中的字符所占的字节数是变化的(1 - 4)，这样有助于大幅降低字符串所占用的内存空间</a>。</p>
<blockquote>
<p><b>ps:</b> : 在语言级别：只有一种字符串类型： <code>str</code>，它通常是以引用类型出现 <code>&amp;str</code>, 也就是我们常说的字符串切片。</p>
</blockquote>
<blockquote>
<p><b>but！</b> 虽然语言级别只有上述的 <code>str</code> 类型，但是在<b>标准库</b>里，还有多种不同用途的字符串类型，其中使用最广的即是 <code>String</code> 类型。<br>举个例子：</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">my_name</span> = <span class="string">&quot;Pascal&quot;</span>;</span><br><span class="line">  <span class="title function_ invoke__">greet</span>(my_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">greet</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;!&quot;</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这块代码看起来是不是很简单明了？无懈可击：greet 函数接受一个字符串类型的 name 参数，然后打印到终端控制台中</p>
<p>但是他运行不起来是会报错的！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">error[E0308]: mismatched types</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:3:11</span></span><br><span class="line">  |</span><br><span class="line">3 |     greet(my_name);</span><br><span class="line">  |     ----- ^^^^^^^- help: try using a conversion method: `.to_string()`</span><br><span class="line">  |     |     |</span><br><span class="line">  |     |     expected `String`, found `&amp;str`</span><br><span class="line">  |     arguments to this function are incorrect</span><br><span class="line">  |</span><br><span class="line">note: function defined here</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:6:6</span></span><br><span class="line">  |</span><br><span class="line">6 |   fn greet(name: String) &#123;</span><br><span class="line">  |      ^^^^^ ------------</span><br></pre></td></tr></table></figure>

<p>这里编译器提示 greet 函数需要一个 String 类型的字符串，却传入了一个 &amp;str 类型的字符串！</p>
<p>其实想要修改也很简单</p>
<h4 id="方法1：修改-greet-函数的参数类型为-str"><a href="#方法1：修改-greet-函数的参数类型为-str" class="headerlink" title="方法1：修改 greet 函数的参数类型为 &amp;str"></a>方法1：修改 greet 函数的参数类型为 &amp;str</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">my_name</span> = &amp;<span class="string">&quot;Pascal&quot;</span>;</span><br><span class="line">   <span class="title function_ invoke__">greet</span>(my_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">greet</span>(name: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;!&quot;</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法2：-将-my-name-转换为-String"><a href="#方法2：-将-my-name-转换为-String" class="headerlink" title="方法2： 将 my_name 转换为 String"></a>方法2： 将 my_name 转换为 String</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_name</span> = <span class="string">&quot;Pascal&quot;</span>;</span><br><span class="line">    <span class="title function_ invoke__">greet</span>(my_name.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">greet</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;!&quot;</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="String-与-str-的转换"><a href="#String-与-str-的转换" class="headerlink" title="String 与 &amp;str 的转换"></a>String 与 &amp;str 的转换</h3><p>有了上面的例子打底，我们也知道了他们其实是可以互相转换的</p>
<ul>
<li>String 类型转为 &amp;str<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello,world!&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">say_hello</span>(&amp;s);</span><br><span class="line">    <span class="title function_ invoke__">say_hello</span>(&amp;s[..]);</span><br><span class="line">    <span class="title function_ invoke__">say_hello</span>(s.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">say_hello</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>&amp;str 转 String<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello,world!&quot;</span>;</span><br><span class="line">    <span class="title function_ invoke__">say_hello</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(s)); <span class="comment">// 使用 String::from() 转换 &amp;str 为 String</span></span><br><span class="line">    <span class="title function_ invoke__">say_hello</span>(s.<span class="title function_ invoke__">to_string</span>()); <span class="comment">// 将 &amp;str 转换为 String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">say_hello</span>(s: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><code>str</code> 类型是硬编码进可执行文件，也无法被修改</li>
<li><code>String</code> 则是一个可增长、可改变且具有所有权的 <code>UTF-8</code> 编码字符串</li>
</ul>
<p><strong>当 <code>Rust</code> 用户提到字符串时，往往指的就是 <code>String</code> 类型和 <code>&amp;str</code> 字符串切片类型，这两个类型都是 <code>UTF-8</code> 编码。</strong></p>
<blockquote>
<p>ps: 其他类型的字符串：</p>
<ul>
<li>OsString</li>
<li>OsStr</li>
<li>CsString </li>
<li>CsStr</li>
<li>等</li>
</ul>
</blockquote>
<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>切片给我感觉就像是字符串解构，或者是 <code>slice</code>（js中） 方法。</p>
<p>举个例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>]; <span class="comment">// hello</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">world</span> = &amp;s[<span class="number">6</span>..<span class="number">11</span>]; <span class="comment">// world</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这就是简单的创建切片的语法：</p>
<ul>
<li>[start, end] -&gt;[开始索引..终止索引]<ul>
<li>使用方括号包括的一个序列</li>
<li>这是一个 右半开的区间</li>
</ul>
</li>
</ul>
<p><img src="/../img/%E5%88%87%E7%89%87%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="切片示意图"></p>
<h4 id="一些延伸"><a href="#一些延伸" class="headerlink" title="一些延伸"></a>一些延伸</h4><ol>
<li>在切片的时候如果我们想从0开始 <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>]; <span class="comment">// hello</span></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello1</span> = &amp;s[..<span class="number">5</span>]; <span class="comment">// hello</span></span><br></pre></td></tr></table></figure></li>
<li>想要包含最后一个字节 <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = s.<span class="title function_ invoke__">len</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">world</span> = &amp;s[<span class="number">6</span>..len]; <span class="comment">// world</span></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">world1</span> = &amp;s[<span class="number">6</span>..]; <span class="comment">// world</span></span><br></pre></td></tr></table></figure></li>
<li>根据方法二获取完整切片 <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = s.<span class="title function_ invoke__">len</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">all</span> = &amp;s[<span class="number">0</span>..len]; <span class="comment">// hello world</span></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">all1</span> = &amp;s[..len]; <span class="comment">// hello world</span></span><br><span class="line"><span class="comment">// 第三种   </span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">all12</span> = &amp;s[..]; <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>ps: 顺带一提：切片的索引必须落在字符之间的边界位置<br>中文在 UTF-8中占三个字节哦</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;你好鸭&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = &amp;s[<span class="number">0</span>..<span class="number">6</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,a); <span class="comment">// 你好</span></span><br></pre></td></tr></table></figure>

<p>当然可以用<code>chars</code>来遍历字符串</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> <span class="string">&quot;你好鸭&quot;</span>.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">你</span><br><span class="line">好</span><br><span class="line">鸭</span><br></pre></td></tr></table></figure>

<p>用<code>bytes</code>来遍历字符串</p>
<p>返回字符串的底层字节数组表现形式</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> <span class="string">&quot;你好鸭&quot;</span>.<span class="title function_ invoke__">bytes</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">228</span><br><span class="line">189</span><br><span class="line">160</span><br><span class="line">229</span><br><span class="line">165</span><br><span class="line">189</span><br><span class="line">233</span><br><span class="line">184</span><br><span class="line">173</span><br></pre></td></tr></table></figure>
<p>推荐一个库：<a href="https://crates.io/crates/utf8_slice">https://crates.io/crates/utf8_slice</a></p>
<h3 id="操作字符串"><a href="#操作字符串" class="headerlink" title="操作字符串"></a>操作字符串</h3><p>由于  <code>String</code> 是可变，他的库也为我们提供了许多可以用的方法</p>
<ol>
<li>追加 <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">`s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;push_str&quot;</span>);`</span><br><span class="line">`s.<span class="title function_ invoke__">push</span>(<span class="string">&quot;push&quot;</span>);`</span><br></pre></td></tr></table></figure>
<ul>
<li><blockquote>
<p>两个方法都是在原有的字符串<strong>尾部</strong>上追加，并<strong>不会</strong>返回新的字符串。</p>
</blockquote>
</li>
<li><blockquote>
<p>由于字符串追加操作要修改原来的字符串，则该字符串必须是可变的，即字符串变量必须由 mut 关键字修饰。</p>
</blockquote>
</li>
</ul>
</li>
<li>插入 (Insert) <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">`s.<span class="title function_ invoke__">insert</span>(<span class="number">1</span>, <span class="symbol">&#x27;insert</span>&#x27;);`</span><br><span class="line">`s.<span class="title function_ invoke__">insert_str</span>(<span class="number">2</span>, <span class="string">&quot;inster_str&quot;</span>);`</span><br></pre></td></tr></table></figure>
<ul>
<li><blockquote>
<p>这俩方法需要传入两个参数，第一个参数是字符（串）插入位置的<strong>索引</strong>，第二个参数是要插入的字符（串），索引从 0 开始计数，<strong>如果越界则会发生错误</strong>。</p>
</blockquote>
</li>
<li><blockquote>
<p>由于字符串追加操作要修改原来的字符串，则该字符串必须是可变的，即字符串变量必须由 mut 关键字修饰。</p>
</blockquote>
</li>
</ul>
</li>
<li>替换 (Replace)<ul>
<li><code>replace</code>  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">str</span> = old.<span class="title function_ invoke__">replace</span>(<span class="string">&quot;replace&quot;</span>, <span class="string">&quot;Replace&quot;</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li><code>replace()</code> 方法接收两个参数，第一个参数是要被替换的字符串，第二个参数是新的字符串。</li>
<li>该方法是返回一个新的字符串，而不是操作原来的字符串。</li>
<li>由于并不在原字符串中进行修改，所以可适用于 <code>String</code> 和 <code>&amp;str</code> 类型</li>
</ol>
</li>
<li><code>replacen</code>  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">str</span> = old.<span class="title function_ invoke__">replace</span>(<span class="string">&quot;replace&quot;</span>, <span class="string">&quot;Replace&quot;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li><code>replacen()</code> 方法接收三个参数，前两个参数与 <code>replace()</code> 方法一样，第三个参数则表示替换的个数。</li>
<li>该方法是返回一个新的字符串，而不是操作原来的字符串。</li>
<li>由于并不在原字符串中进行修改，所以可适用于 <code>String</code> 和 <code>&amp;str</code> 类型</li>
</ol>
</li>
<li><code>replace_range</code>  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="type">str</span>.<span class="title function_ invoke__">replace_range</span>(<span class="number">7</span>..<span class="number">8</span>, <span class="string">&quot;R&quot;</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li>第一个参数是要替换字符串的范围（Range），第二个参数是新的字符串。</li>
<li>该方法是直接操作原来的字符串，不会返回新的字符串。该方法需要使用 <code>mut</code> 关键字修饰。</li>
</ol>
</li>
</ul>
</li>
<li>删除 (Delete)<ol>
<li><code>pop</code> <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">p1</span> = <span class="type">str</span>.<span class="title function_ invoke__">pop</span>();</span><br></pre></td></tr></table></figure>
<ol>
<li>删除并返回字符串的最后一个字符</li>
<li>该方法是直接操作原来的字符串</li>
<li>存在返回值，其返回值是一个 Option 类型，如果字符串为空，则返回 None。</li>
</ol>
</li>
<li><code>remove</code> <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">p1</span> = <span class="type">str</span>.<span class="title function_ invoke__">remove</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li>删除并返回字符串中指定位置的字符</li>
<li>该方法是直接操作原来的字符串</li>
<li>存在返回值，其返回值是删除位置的字符串，只接收一个参数，表示该字符起始索引位置。</li>
<li><blockquote>
<p><code>remove()</code> 方法是按照字节来处理字符串的，如果参数所给的位置不是合法的字符边界，则会发生错误。</p>
</blockquote>
</li>
</ol>
</li>
<li><code>truncate</code> <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="type">str</span>.<span class="title function_ invoke__">truncate</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li>删除字符串中从指定位置开始到结尾的全部字符</li>
<li>该方法是直接操作原来的字符串。</li>
<li>无返回值.</li>
<li>是按照字节来处理字符串的，如果参数所给的位置不是合法的字符边界，则会发生错误。</li>
</ol>
</li>
<li><code>clear</code> <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="type">str</span>.<span class="title function_ invoke__">clear</span>();</span><br></pre></td></tr></table></figure>
<ol>
<li>清空字符串</li>
<li>该方法是直接操作原来的字符串<br> 3.相当于 truncate() 方法参数为 0 的时候</li>
</ol>
</li>
</ol>
</li>
<li>连接 (Concatenate)<ol>
<li>使用 + 或者 +&#x3D; 连接字符串 <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello,&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line"><span class="comment">// 在下句中，s1的所有权被转移走了，因此后面不能再使用s1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = s1 + &amp;s2;</span><br></pre></td></tr></table></figure>
<ul>
<li>是返回一个新的字符串，所以变量声明可以不需要 mut 关键字修饰</li>
</ul>
</li>
<li>使用 format! 连接字符串 <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;rust&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;!&quot;</span>, s1, s2); <span class="comment">// hello rust</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 1. 使用 push_str 操作</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    s1.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world!&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;操作: push_str(&#x27;, world!&#x27;)\n结果: &#123;&#125;\n&quot;</span>, s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 使用 push 操作</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">    s2.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    s2.<span class="title function_ invoke__">push</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    s2.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;R&#x27;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;操作: push(&#x27;!&#x27;), push(&#x27; &#x27;), push(&#x27;R&#x27;)\n结果: &#123;&#125;\n&quot;</span>, s2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 使用 insert 操作</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s3</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Goodbye&quot;</span>);</span><br><span class="line">    s3.<span class="title function_ invoke__">insert</span>(<span class="number">4</span>, <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;操作: insert(4, &#x27;-&#x27;)\n结果: &#123;&#125;\n&quot;</span>, s3);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 使用 insert_str 操作</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s4</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rustaceans&quot;</span>);</span><br><span class="line">    s4.<span class="title function_ invoke__">insert_str</span>(<span class="number">4</span>, <span class="string">&quot; love&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;操作: insert_str(4, &#x27; love&#x27;)\n结果: &#123;&#125;\n&quot;</span>, s4);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 使用 replace 操作</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s5</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;I love Rust&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s5_replaced</span> = s5.<span class="title function_ invoke__">replace</span>(<span class="string">&quot;love&quot;</span>, <span class="string">&quot;enjoy&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;操作: replace(&#x27;love&#x27;, &#x27;enjoy&#x27;)\n结果: &#123;&#125;\n&quot;</span>, s5_replaced);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 使用 replacen 操作</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s6</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s6_replacen</span> = s6.<span class="title function_ invoke__">replacen</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;操作: replacen(&#x27;a&#x27;, &#x27;A&#x27;, 2)\n结果: &#123;&#125;\n&quot;</span>, s6_replacen);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 使用 replace_range 操作</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s7</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line">    s7.<span class="title function_ invoke__">replace_range</span>(<span class="number">2</span>..<span class="number">5</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;操作: replace_range(2..5, &#x27;abc&#x27;)\n结果: &#123;&#125;\n&quot;</span>, s7);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 使用 pop 操作</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s8</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">popped_char</span> = s8.<span class="title function_ invoke__">pop</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;操作: pop() -&gt; &#x27;&#123;&#125;&#x27;\n结果: &#123;&#125;\n&quot;</span>, popped_char.<span class="title function_ invoke__">unwrap</span>(), s8);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9. 使用 remove 操作</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s9</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abcdef&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">removed_char</span> = s9.<span class="title function_ invoke__">remove</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;操作: remove(2) -&gt; &#x27;&#123;&#125;&#x27;\n结果: &#123;&#125;\n&quot;</span>, removed_char, s9);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 10. 使用 truncate 操作</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s10</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;This is a long string.&quot;</span>);</span><br><span class="line">    s10.<span class="title function_ invoke__">truncate</span>(<span class="number">7</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;操作: truncate(7)\n结果: &#123;&#125;\n&quot;</span>, s10);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 11. 使用 clear 操作</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s11</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Not empty&quot;</span>);</span><br><span class="line">    s11.<span class="title function_ invoke__">clear</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;操作: clear()\n结果: &#x27;&#123;&#125;&#x27;\n&quot;</span>, s11);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 12. 使用 format! 操作</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">formatted</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, <span class="string">&quot;Rust&quot;</span>, <span class="string">&quot;Fun&quot;</span>, <span class="string">&quot;Awesome!&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;操作: format!(&#x27;&#123;&#125; + &#123;&#125; = &#123;&#125;&#x27;)\n结果: &#123;&#125;\n&quot;</span>, <span class="string">&quot;Rust&quot;</span>, <span class="string">&quot;Fun&quot;</span>, <span class="string">&quot;Awesome!&quot;</span>, formatted);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">操作: push_str(&#x27;, world!&#x27;)</span><br><span class="line">结果: Hello, world!</span><br><span class="line"></span><br><span class="line">------------------------</span><br><span class="line">操作: push(&#x27;!&#x27;), push(&#x27; &#x27;), push(&#x27;R&#x27;)</span><br><span class="line">结果: Hi! R</span><br><span class="line"></span><br><span class="line">------------------------</span><br><span class="line">操作: insert(4, &#x27;-&#x27;)</span><br><span class="line">结果: Good-bye</span><br><span class="line"></span><br><span class="line">------------------------</span><br><span class="line">操作: insert_str(4, &#x27; love&#x27;)</span><br><span class="line">结果: Rust loveaceans</span><br><span class="line"></span><br><span class="line">------------------------</span><br><span class="line">操作: replace(&#x27;love&#x27;, &#x27;enjoy&#x27;)</span><br><span class="line">结果: I enjoy Rust</span><br><span class="line"></span><br><span class="line">------------------------</span><br><span class="line">操作: replacen(&#x27;a&#x27;, &#x27;A&#x27;, 2)</span><br><span class="line">结果: bAnAna</span><br><span class="line"></span><br><span class="line">------------------------</span><br><span class="line">操作: replace_range(2..5, &#x27;abc&#x27;)</span><br><span class="line">结果: 12abc67890</span><br><span class="line"></span><br><span class="line">------------------------</span><br><span class="line">操作: pop() -&gt; &#x27;!&#x27;</span><br><span class="line">结果: Hello</span><br><span class="line"></span><br><span class="line">------------------------</span><br><span class="line">操作: remove(2) -&gt; &#x27;c&#x27;</span><br><span class="line">结果: abdef</span><br><span class="line"></span><br><span class="line">------------------------</span><br><span class="line">操作: truncate(7)</span><br><span class="line">结果: This is</span><br><span class="line"></span><br><span class="line">------------------------</span><br><span class="line">操作: clear()</span><br><span class="line">结果: &#x27;&#x27;</span><br><span class="line"></span><br><span class="line">------------------------</span><br><span class="line">操作: format!(&#x27;Rust + Fun = Awesome!&#x27;)</span><br><span class="line">结果: Rust + Fun = Awesome!</span><br><span class="line"></span><br><span class="line">------------------------</span><br></pre></td></tr></table></figure>
<h3 id="字符串深度剖析"><a href="#字符串深度剖析" class="headerlink" title="字符串深度剖析"></a>字符串深度剖析</h3><p><strong>那么问题来了，为啥 <code>String</code> 可变，而字符串字面值 <code>str</code> 却不可以？</strong></p>
<blockquote>
<p><a href="https://course.rs/basic/compound-type/string-slice.html#%E5%AD%97%E7%AC%A6">就字符串字面值来说，我们在编译时就知道其内容，最终字面值文本被直接硬编码进可执行文件中，这使得字符串字面值快速且高效，这主要得益于字符串字面值的不可变性。不幸的是，我们不能为了获得这种性能，而把每一个在编译时大小未知的文本都放进内存中（你也做不到！），因为有的字符串是在程序运行得过程中动态生成的。</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Rust学习笔记</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust-复合类型-数组</title>
    <url>/2024/10/02/Rust-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是 Rust 的基本类型，是固定长度的，这点与其他编程语言不同，其它编程语言的数组往往是可变长度的</p>
<blockquote>
<p>所以当我们越界访问的时候会导致程序报错</p>
</blockquote>
<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个语法和js十分的相似，<code>but：</code>它的元素类型大小固定，且长度也是固定，不过失之东隅收之桑榆，数组 <code>array</code> 是存储在栈上，性能也会非常优秀~</p>
<blockquote>
<p>ps: 还有动态数组哦，当我们不确定是使用数组还是静态数组的时候，那就要用后者哦！</p>
</blockquote>
<h3 id="数组切片"><a href="#数组切片" class="headerlink" title="数组切片"></a>数组切片</h3><p>数组切片允许我们引用数组的一部分：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span>: &amp;[<span class="type">i32</span>] = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(slice, &amp;[<span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure>
<h2 id="创建动态数组"><a href="#创建动态数组" class="headerlink" title="创建动态数组"></a>创建动态数组</h2><h3 id="Vec-new"><a href="#Vec-new" class="headerlink" title="Vec::new"></a>Vec::new</h3><p>使用 Vec::new 创建动态数组是最 rusty 的方式，它调用了 Vec 中的 new 关联函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br></pre></td></tr></table></figure>

<h3 id="vec"><a href="#vec" class="headerlink" title="vec![]"></a>vec![]</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ps 向数组尾部添加元素，可以使用 push 方法：<br>but! 与其它类型一样，必须将变量声明为 mut 后，才能进行修改。</p>
</blockquote>
<h3 id="Vector-的排序"><a href="#Vector-的排序" class="headerlink" title="Vector 的排序"></a>Vector 的排序</h3><p>在 rust 里，实现了两种排序算法，分别为稳定的排序 sort 和 sort_by，以及非稳定排序 sort_unstable 和 </p>
<blockquote>
<p>当然，这个所谓的 非稳定 并不是指排序算法本身不稳定，而是指在排序过程中对相等元素的处理方式。在 稳定 排序算法里，对相等的元素，不会对其进行重新排序。而在 不稳定 的算法里则不保证这点。<br>总体而言，非稳定 排序的算法的速度会优于 稳定 排序算法，同时，稳定 排序还会额外分配原数组一半的空间。</p>
</blockquote>
]]></content>
      <categories>
        <category>Rust学习笔记</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust-枚举</title>
    <url>/2024/09/25/Rust-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B-%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>枚举这个基础定义不难，学过ts的都有些概念, <code>rust</code> 枚举</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">  Dog,</span><br><span class="line">  Cat,</span><br><span class="line">  Bride,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="枚举值"><a href="#枚举值" class="headerlink" title="枚举值"></a>枚举值</h2><p>现在来创建 <code>Pet</code> 枚举类型的两个成员实例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span> <span class="comment">// 为枚举 Pet 实现 Debug 特性</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">    Dog,</span><br><span class="line">    Cat,</span><br><span class="line">    <span class="meta">#[allow(dead_code)]</span> <span class="comment">// 忽略未使用的 Bird 变体的警告</span></span><br><span class="line">    Bird, <span class="comment">// 这里应该是 Bird 而不是 Bride</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">dog</span> = Pet::Dog;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cat</span> = Pet::Cat;</span><br><span class="line">    <span class="title function_ invoke__">print_pet</span>(dog);</span><br><span class="line">    <span class="title function_ invoke__">print_pet</span>(cat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_pet</span>(name: Pet) &#123;</span><br><span class="line">    <span class="comment">// 打印枚举的值，使用 &#123;:?&#125; 以调试格式输出</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Dog</span><br><span class="line">Cat</span><br></pre></td></tr></table></figure>

<h3 id="如何自定义值？"><a href="#如何自定义值？" class="headerlink" title="如何自定义值？"></a>如何自定义值？</h3><p>在我们日常开发中，总会遇到特殊情况：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    Man,</span><br><span class="line">    Woman,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们创建了 <code>Human</code> 这个枚举类，如果我们想要做记录，来自哪里多少岁这样，那我们可以这样做</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span> <span class="comment">// 为枚举 Pet 实现 Debug 特性</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    Man &#123; region: <span class="type">String</span>, age: <span class="type">u32</span> &#125;,</span><br><span class="line">    Woman &#123; region: <span class="type">String</span>, age: <span class="type">u32</span> &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">c1</span> = Human::Man &#123;</span><br><span class="line">        region: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;北京&quot;</span>),</span><br><span class="line">        age: <span class="number">30</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">c2</span> = Human::Woman &#123;</span><br><span class="line">        region: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;四川&quot;</span>),</span><br><span class="line">        age: <span class="number">25</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">print_human</span>(c1);</span><br><span class="line">    <span class="title function_ invoke__">print_human</span>(c2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_human</span>(name: Human) &#123;</span><br><span class="line">    <span class="keyword">match</span> name &#123;</span><br><span class="line">        Human::Man &#123; region, age &#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;来自 &#123;&#125;, &#123;&#125; 岁&quot;</span>, region, age);</span><br><span class="line">        &#125;</span><br><span class="line">        Human::Woman &#123; region, age &#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;来自 &#123;&#125;, &#123;&#125; 岁&quot;</span>, region, age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">来自 北京, 30 岁</span><br><span class="line">来自 四川, 25 岁</span><br></pre></td></tr></table></figure>
<p>当然这种需求，结构体也可以实现，但是会复杂很多就是了。</p>
<h3 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h3><p>再来看一个来自标准库中的例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Ipv4Addr</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Ipv6Addr</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(Ipv4Addr),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(Ipv6Addr),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在举一个例子"><a href="#在举一个例子" class="headerlink" title="在举一个例子"></a>在举一个例子</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m1</span> = Message::Quit;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m2</span> = Message::Move&#123;x:<span class="number">1</span>,y:<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m3</span> = Message::<span class="title function_ invoke__">ChangeColor</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该枚举类型代表一条消息，它包含四个不同的成员：</p>
<ul>
<li>Quit 没有任何关联数据</li>
<li>Move 包含一个匿名结构体</li>
<li>Write 包含一个 String 字符串</li>
<li>ChangeColor 包含三个 i32</li>
</ul>
<blockquote>
<p>从这些例子可以看出，任何类型的数据都可以放入枚举成员中: 例如字符串、数值、结构体甚至另一个枚举。</p>
</blockquote>
]]></content>
      <categories>
        <category>Rust学习笔记</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust-复合类型-结构体</title>
    <url>/2024/09/26/Rust-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B-%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>常常用 js 的小伙伴会觉得很熟悉，就是类似 js 的对象的感觉，学结构体的时候，是不是就想起一句话：万物皆对象！</p>
<p>结构体跟之前讲过的元组有些相像：都是由多种类型组合而成。但是与元组不同的是，结构体可以为内部的每个字段起一个富有含义的名称。因此结构体更加灵活更加强大，你无需依赖这些字段的顺序来访问和解析它们。</p>
<h2 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h2><p>如何声明一个结构体：<code>struct</code> +  <code>名称</code> + 多个  <code>字段</code><br>举个例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建结构体实例"><a href="#创建结构体实例" class="headerlink" title="创建结构体实例"></a>创建结构体实例</h3><p>我们用 <code>User</code> 结构体进行创建</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">    username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ps:</p>
<ol>
<li>初始化实例时，每个字段都需要进行初始化</li>
<li>初始化时的字段顺序不需要和结构体定义时的顺序一致</li>
</ol>
</blockquote>
<h3 id="访问-修改"><a href="#访问-修改" class="headerlink" title="访问+修改"></a>访问+修改</h3><p>通过 . 操作符就可以访问结构体实例内部的字段值，也可以修改它们：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">user1.email = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;anotheremail@example.com&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;用户&#123;&#125;,邮件&#123;&#125;&quot;</span>, user1.username, user1.email);</span><br></pre></td></tr></table></figure>

<h3 id="demo代码"><a href="#demo代码" class="headerlink" title="demo代码"></a>demo代码</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user1</span> = User &#123;</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    user1.email = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;anotheremail@example.com&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;用户&#123;&#125;,邮件&#123;&#125;&quot;</span>, user1.username, user1.email);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">用户someusername123,邮件anotheremail@example.com</span><br></pre></td></tr></table></figure>

<h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><ul>
<li>简化结构体创建  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email,</span><br><span class="line">        username,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  当函数参数和结构体字段同名时，可以直接使用缩略的方式进行初始化，跟 TypeScript 中一模一样</li>
<li>结构体更新语法  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">    ..user1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们只需要对 <code>email</code> 进行赋值，剩下的通过结构体更新语法 <code>..user1</code> 即可完成</li>
<li><code>..</code> 语法表明凡是我们没有显式声明的字段，全部从 <code>user1</code> 中自动获取。需要注意的是 <code>..user1</code> 必须在结构体的尾部使用。</li>
</ul>
</li>
</ul>
<blockquote>
<p>结构体更新语法跟赋值语句 &#x3D; 非常相像，因此在上面代码中，user1 的部分字段所有权被转移到 user2 中：username 字段发生了所有权转移，作为结果，user1 无法再被使用。<br>聪明的读者肯定要发问了：明明有三个字段进行了自动赋值，为何只有 username 发生了所有权转移？<br>仔细回想一下所有权那一节的内容，我们提到了 Copy 特征：实现了 Copy 特征的类型无需所有权转移，可以直接在赋值时进行 数据拷贝，其中 bool 和 u64 类型就实现了 Copy 特征，因此 active 和 sign_in_count 字段在赋值给 user2 时，仅仅发生了拷贝，而不是所有权转移。<br>值得注意的是：username 所有权被转移给了 user2，导致了 user1 无法再被使用，但是并不代表 user1 内部的其它字段不能被继续使用，</p>
</blockquote>
<blockquote>
<p>推荐细看：<a href="https://course.rs/basic/compound-type/struct.html">https://course.rs/basic/compound-type/struct.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Rust学习笔记</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust-集合类型</title>
    <url>/2024/09/02/Rust-%E5%B8%B8%E8%A7%81%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h1><p><code>Vector</code>、<code>HashMap</code> 再加上之前的 <code>String</code> 类型，是标准库中最最常用的集合类型，可以说，几乎任何一段代码中都可以找到它们的身影!</p>
<h2 id="动态数组-Vector"><a href="#动态数组-Vector" class="headerlink" title="动态数组 Vector"></a>动态数组 Vector</h2><p>动态数组类型用 <code>Vec&lt;T&gt;</code>表示。</p>
<blockquote>
<p>ps: 动态数组允许你存储多个值，这些值在内存中一个紧挨着另一个排列，因此访问其中某个元素的成本非常低。动态数组只能存储相同类型的元素，如果你想存储不同类型的元素，可以使用之前讲过的枚举类型或者特征对象。</p>
</blockquote>
<h3 id="创建和初始化"><a href="#创建和初始化" class="headerlink" title="创建和初始化"></a>创建和初始化</h3><p>在 Rust 中，有多种方式可以创建动态数组。</p>
<h4 id="使用-Vec-new-创建"><a href="#使用-Vec-new-创建" class="headerlink" title="使用 Vec::new 创建"></a>使用 <code>Vec::new</code> 创建</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>()</span><br></pre></td></tr></table></figure>

<h3 id="使用宏-vec-来创建数组"><a href="#使用宏-vec-来创建数组" class="headerlink" title="使用宏 vec! 来创建数组"></a>使用宏 <code>vec!</code> 来创建数组</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">1</span>); <span class="comment">// 往尾部添加一个元素</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>读取指定位置的元素有两种方式可选：</p>
<ul>
<li>通过下标索引访问。</li>
<li>使用 get 方法。</li>
</ul>
<h4 id="通过下标索引访问。"><a href="#通过下标索引访问。" class="headerlink" title="通过下标索引访问。"></a>通过下标索引访问。</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v3</span>: &amp;<span class="type">i32</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;第三个元素是 &#123;&#125;&quot;</span>, v3);</span><br></pre></td></tr></table></figure>

<h4 id="使用-get-方法"><a href="#使用-get-方法" class="headerlink" title="使用 get 方法"></a>使用 get 方法</h4><p>get 的话，返回的是一个 option，就需要用我们之前学过的 match 进行模式匹配：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">match</span> v.<span class="title function_ invoke__">get</span>(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;第三个元素是 &#123;third&#125;&quot;</span>),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;啥都没有&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h4><p>这两种方法都挺不错的，那我们平常用哪一个好呢？</p>
<blockquote>
<p>答案很简单：<strong>你确保索引不会越界的时候，就用索引访问，否则用 .get</strong></p>
</blockquote>
<h3 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line">v[<span class="number">2</span>] = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;v:&#123;:?&#125;&quot;</span>, v);</span><br></pre></td></tr></table></figure>

<h3 id="遍历元素"><a href="#遍历元素" class="headerlink" title="遍历元素"></a>遍历元素</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="title class_">i</span>: &amp;<span class="type">i32</span> <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>说白了就是键值对（key-value）的数据结构，而且<code>HashMap</code>的查询方法 均复杂度为 <code>O(1)</code></p>
<h3 id="创建-HashMap"><a href="#创建-HashMap" class="headerlink" title="创建 HashMap"></a>创建 HashMap</h3><p>跟创建动态数组 <code>Vec</code> 的方法类似，可以使用 <code>new</code> 方法来创建 <code>HashMap</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br></pre></td></tr></table></figure>
<h3 id="使用迭代器和-collect-方法创建"><a href="#使用迭代器和-collect-方法创建" class="headerlink" title="使用迭代器和 collect 方法创建"></a>使用迭代器和 collect 方法创建</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">teams_list</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        (<span class="string">&quot;中国队&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">100</span>),</span><br><span class="line">        (<span class="string">&quot;美国队&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">10</span>),</span><br><span class="line">        (<span class="string">&quot;日本队&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">50</span>),</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">teams_map</span>: HashMap&lt;_,_&gt; = teams_list.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,teams_map)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很简单，<code>into_iter</code> 方法将列表转为迭代器，接着通过 <code>collect</code> 进行收集，不过需要注意的是，<code>collect</code> 方法在内部实际上支持生成多种类型的目标集合，因此我们需要通过类型标注 <code>HashMap&lt;_,_&gt;</code> 来告诉编译器：请帮我们收集为 <code>HashMap</code> 集合类型，具体的 <code>KV</code> 类型，麻烦编译器您老人家帮我们推导。</p>
<h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, map)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;a&quot;</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">score</span>: <span class="type">Option</span>&lt;&amp;<span class="type">i32</span>&gt; = map.<span class="title function_ invoke__">get</span>(&amp;name);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, score)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>ps: 敲黑板！重点</p>
<ul>
<li>get 方法返回一个 Option&lt;&amp;i32&gt; 类型：当查询不到时，会返回一个 None，查询到时返回 Some(&amp;i32)</li>
<li>&amp;i32 是对 HashMap 中值的借用，如果不使用借用，可能会发生所有权的转移</li>
</ul>
</blockquote>
<h3 id="更新值"><a href="#更新值" class="headerlink" title="更新值"></a>更新值</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;a&quot;</span>), <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">old</span> = map.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;a&quot;</span>), <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(old, <span class="title function_ invoke__">Some</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;a&quot;</span>), <span class="number">1</span>);</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;b&quot;</span>), <span class="number">2</span>);</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;c&quot;</span>), <span class="number">3</span>);</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;d&quot;</span>), <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (key, map_item) <span class="keyword">in</span> &amp;map &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>, key, map_item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rust 内部已经帮我们做好了 迭代的工作了</p>
]]></content>
      <categories>
        <category>Rust学习笔记</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust-模块化</title>
    <url>/2024/10/18/Rust-%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Rust-包-模块"><a href="#Rust-包-模块" class="headerlink" title="Rust 包+模块"></a>Rust 包+模块</h1><p>Rust 的包管理工具：</p>
<ul>
<li>包(Crate)：一个由多个模块组成的树形结构，可以作为三方库进行分发，也可以生成可执行文件进行运行</li>
<li>项目(Packages)：一个 Cargo 提供的 feature，可以用来构建、测试和分享包</li>
<li>工作空间(WorkSpace)：对于大型项目，可以进一步将多个包联合在一起，组织成工作空间</li>
<li>模块(Module)：可以一个文件多个模块，也可以一个文件一个模块，模块可以被认为是真实项目中的代码组织单元</li>
</ul>
<h2 id="Crate-包含"><a href="#Crate-包含" class="headerlink" title="Crate 包含"></a>Crate 包含</h2><p>包是一个独立的可编译单元，它编译后会生成一个可执行文件或者一个库</p>
<h2 id="Package"><a href="#Package" class="headerlink" title="Package"></a>Package</h2><p><code>Package</code> 就是一个项目，因此它包含有独立的 <code>Cargo.toml</code> 文件，以及因为功能性被组织在一起的一个或多个包。一个 <code>Package</code> 只能包含一个库<code>(library)</code>类型的包，但是可以包含多个二进制可执行类型的包。</p>
<h3 id="创建二进制-Package"><a href="#创建二进制-Package" class="headerlink" title="创建二进制 Package"></a>创建二进制 Package</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">cargo new my-project</span><br></pre></td></tr></table></figure>
<p>使用 <code>Cargo</code> 创建了一个名称是 <code>my-project</code> 的 <code>Package</code></p>
<h3 id="创建一个库类型的-Package"><a href="#创建一个库类型的-Package" class="headerlink" title="创建一个库类型的 Package"></a>创建一个库类型的 Package</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">cargo new my-lib --lib</span><br></pre></td></tr></table></figure>
<p>but: 我们在试图运行<code>my-lib</code>，就会报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">error: a bin target must be available for `cargo run`</span><br></pre></td></tr></table></figure>
<blockquote>
<p>beacuse: 库类型的 Package 只能作为三方库被其它项目引用，而不能独立运行，只有之前的二进制 Package 才可以运行</p>
</blockquote>
<h3 id="典型的-Package-结构"><a href="#典型的-Package-结构" class="headerlink" title="典型的 Package 结构"></a>典型的 Package 结构</h3><p>在 Rust 中，典型的包（Package）结构如下所示：</p>
<p>结合多个库包和主二进制包的典型结构如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── Cargo.toml</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── src</span><br><span class="line">│   ├── main.rs</span><br><span class="line">│   ├── lib.rs</span><br><span class="line">│   └── bin</span><br><span class="line">│       └── main1.rs</span><br><span class="line">│       └── main2.rs</span><br><span class="line">├── tests</span><br><span class="line">│   └── some_integration_tests.rs</span><br><span class="line">├── benches</span><br><span class="line">│   └── simple_bench.rs</span><br><span class="line">└── examples</span><br><span class="line">    └── simple_example.rs</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ps: 一个 Package 只能包含一个库(library)类型的包，但是可以包含多个二进制可执行类型的包</p>
</blockquote>
<h3 id="主要组成部分："><a href="#主要组成部分：" class="headerlink" title="主要组成部分："></a>主要组成部分：</h3><ul>
<li>唯一库包：src&#x2F;lib.rs</li>
<li>默认二进制包：src&#x2F;main.rs，编译后生成的可执行文件与 Package 同名</li>
<li>其余二进制包：src&#x2F;bin&#x2F;main1.rs 和 src&#x2F;bin&#x2F;main2.rs，它们会分别生成一个文件同名的二进制可执行文件</li>
<li>集成测试文件：tests 目录下</li>
<li>基准性能测试 benchmark 文件：benches 目录下</li>
<li>项目示例：examples 目录下</li>
</ul>
<h2 id="Rust-中的模块（Module）"><a href="#Rust-中的模块（Module）" class="headerlink" title="Rust 中的模块（Module）"></a>Rust 中的模块（Module）</h2><p>模块是 Rust 代码组织的基本单位，用于将相关的功能和类型分组，从而提高代码的可读性和可维护性。模块为代码提供了命名空间，避免名称冲突。</p>
<h3 id="1-创建模块"><a href="#1-创建模块" class="headerlink" title="1. 创建模块"></a>1. 创建模块</h3><p>在 Rust 中，可以通过以下方式创建模块：</p>
<ul>
<li><strong>在文件中定义模块</strong>:<br>通过 <code>mod</code> 关键字在文件中定义模块。例如，创建一个名为 <code>my_module</code> 的模块。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs 或 src/main.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> my_module &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">greet</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Hello from my_module!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-访问模块中的项"><a href="#2-访问模块中的项" class="headerlink" title="2. 访问模块中的项"></a>2. 访问模块中的项</h3><ul>
<li><strong>访问模块中的公共项</strong>:<br>使用 <code>pub</code> 关键字将模块中的函数或结构体声明为公共，使其可在模块外部访问。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs 或 src/main.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> my_module &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">greet</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Hello from my_module!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    my_module::<span class="title function_ invoke__">greet</span>();  <span class="comment">// 调用模块中的公共函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-使用外部文件定义模块"><a href="#3-使用外部文件定义模块" class="headerlink" title="3. 使用外部文件定义模块"></a>3. 使用外部文件定义模块</h3><p>模块可以被拆分到多个文件中，以便更好地组织代码。比如，可以将 <code>my_module</code> 的实现放在单独的文件中。</p>
<ul>
<li><strong>目录结构</strong>:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line">├── lib.rs</span><br><span class="line">└── my_module.rs</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>my_module.rs</strong>:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">greet</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello from my_module!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>lib.rs</strong>:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> my_module;  <span class="comment">// 引入 my_module.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    my_module::<span class="title function_ invoke__">greet</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-嵌套模块"><a href="#4-嵌套模块" class="headerlink" title="4. 嵌套模块"></a>4. 嵌套模块</h3><p>模块可以嵌套在其他模块内部，形成层次结构。可以通过文件夹结构来组织嵌套模块。</p>
<ul>
<li><strong>目录结构</strong>:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line">├── lib.rs</span><br><span class="line">└── outer/</span><br><span class="line">    └── inner.rs</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>lib.rs</strong>:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> outer;  <span class="comment">// 引入 outer.rs</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>outer&#x2F;mod.rs</strong>:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> inner;  <span class="comment">// 引入 inner.rs</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>outer&#x2F;inner.rs</strong>:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">greet</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello from inner module!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>访问嵌套模块中的项</strong>:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    outer::inner::<span class="title function_ invoke__">greet</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-使用模块的好处"><a href="#5-使用模块的好处" class="headerlink" title="5. 使用模块的好处"></a>5. 使用模块的好处</h3><ul>
<li><strong>命名空间</strong>: 避免名称冲突，使代码更清晰。</li>
<li><strong>可维护性</strong>: 使代码更容易组织和管理。</li>
<li><strong>代码重用</strong>: 通过模块可以重用功能，而不必重复编写代码。</li>
</ul>
]]></content>
      <categories>
        <category>Rust学习笔记</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust-模式匹配-demo</title>
    <url>/2024/09/02/Rust-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D-demo/</url>
    <content><![CDATA[<p>了解了！以下是按你的要求，包含引言、代码、注释和解析的完整 Markdown 文章格式，涵盖所有模式匹配内容。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="section"># Rust 模式匹配详解</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 引言</span></span><br><span class="line"></span><br><span class="line">Rust 的模式匹配功能极其强大，可以让代码更具可读性并处理复杂数据结构。它不仅可以匹配字面值，还能匹配变量、枚举、结构体等复杂类型。此外，Rust 还提供了一些便利的语法糖，比如通过 <span class="code">`..=`</span> 匹配值的范围，使用 <span class="code">`@`</span> 绑定变量等。本文将详细讲解各种模式匹配用法，并通过代码示例来帮助你更好地理解。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="section">## 1. 匹配字面值</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 示例代码：</span></span><br><span class="line"><span class="code">```rust</span></span><br><span class="line"><span class="code">fn main() &#123;</span></span><br><span class="line"><span class="code">    let x = 5;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    match x &#123;</span></span><br><span class="line"><span class="code">        1 =&gt; println!(&quot;One!&quot;),</span></span><br><span class="line"><span class="code">        3 =&gt; println!(&quot;Three!&quot;),</span></span><br><span class="line"><span class="code">        5 =&gt; println!(&quot;Five!&quot;),</span></span><br><span class="line"><span class="code">        _ =&gt; println!(&quot;Something else!&quot;), // _ 用于匹配所有其他情况</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h3><p>这里我们使用 <code>match</code> 语句对变量 <code>x</code> 进行模式匹配。具体的分支包括匹配 <code>1</code>、<code>3</code> 和 <code>5</code> 的字面值。<code>_</code> 是默认分支，用于匹配所有未被显式列出的情况。</p>
<hr>
<h2 id="2-匹配命名变量"><a href="#2-匹配命名变量" class="headerlink" title="2. 匹配命名变量"></a>2. 匹配命名变量</h2><h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="number">50</span>) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Matched 50&quot;</span>),  <span class="comment">// 匹配具体的值 50</span></span><br><span class="line">        <span class="title function_ invoke__">Some</span>(n) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Matched, n = &#123;&#125;&quot;</span>, n),  <span class="comment">// 绑定 Some 的值到变量 n</span></span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;None&quot;</span>),  <span class="comment">// 匹配 None 情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析：-1"><a href="#解析：-1" class="headerlink" title="解析："></a>解析：</h3><p>在这个示例中，<code>Some(50)</code> 只匹配包含 <code>50</code> 的 <code>Some</code>，而 <code>Some(n)</code> 可以匹配任意 <code>Some</code>，并将值绑定到变量 <code>n</code> 上。<code>None</code> 则匹配空的 <code>Option</code>。</p>
<hr>
<h2 id="3-单分支多模式"><a href="#3-单分支多模式" class="headerlink" title="3. 单分支多模式"></a>3. 单分支多模式</h2><h3 id="示例代码：-1"><a href="#示例代码：-1" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="number">1</span> | <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;One or Two&quot;</span>),  <span class="comment">// 单分支匹配多个值</span></span><br><span class="line">        <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Three&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Something else&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析：-2"><a href="#解析：-2" class="headerlink" title="解析："></a>解析：</h3><p>在这个例子中，<code>1 | 2</code> 让一个分支可以匹配多个模式。这里，当 <code>x</code> 是 <code>1</code> 或 <code>2</code> 时，会进入同一个分支。</p>
<hr>
<h2 id="4-通过序列-匹配值的范围"><a href="#4-通过序列-匹配值的范围" class="headerlink" title="4. 通过序列 ..= 匹配值的范围"></a>4. 通过序列 <code>..=</code> 匹配值的范围</h2><h3 id="示例代码：-2"><a href="#示例代码：-2" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="number">1</span>..=<span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;x is between 1 and 5&quot;</span>),  <span class="comment">// 匹配范围 1 到 5</span></span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;x is something else&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析：-3"><a href="#解析：-3" class="headerlink" title="解析："></a>解析：</h3><p><code>1..=5</code> 使用范围语法来匹配 <code>x</code> 的值是否在 <code>1</code> 到 <code>5</code> 之间（包括 1 和 5）。这可以非常方便地处理连续值的匹配。</p>
<hr>
<h2 id="5-解构并分解值"><a href="#5-解构并分解值" class="headerlink" title="5. 解构并分解值"></a>5. 解构并分解值</h2><h3 id="5-1-解构结构体"><a href="#5-1-解构结构体" class="headerlink" title="5.1 解构结构体"></a>5.1 解构结构体</h3><h3 id="示例代码：-3"><a href="#示例代码：-3" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point &#123; x: <span class="number">10</span>, y: <span class="number">20</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> p &#123;</span><br><span class="line">        Point &#123; x, y &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Point has x = &#123;&#125;, y = &#123;&#125;&quot;</span>, x, y),  <span class="comment">// 解构结构体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析：-4"><a href="#解析：-4" class="headerlink" title="解析："></a>解析：</h3><p>这里我们通过模式匹配直接解构了 <code>Point</code> 结构体，将其 <code>x</code> 和 <code>y</code> 成员提取出来。</p>
<hr>
<h3 id="5-2-解构枚举"><a href="#5-2-解构枚举" class="headerlink" title="5.2 解构枚举"></a>5.2 解构枚举</h3><h3 id="示例代码：-4"><a href="#示例代码：-4" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">coin</span> = Coin::Quarter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Penny&quot;</span>),</span><br><span class="line">        Coin::Nickel =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Nickel&quot;</span>),</span><br><span class="line">        Coin::Dime =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Dime&quot;</span>),</span><br><span class="line">        Coin::Quarter =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Quarter&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析：-5"><a href="#解析：-5" class="headerlink" title="解析："></a>解析：</h3><p>这个例子展示了如何使用模式匹配解构枚举类型，并处理每个变体的情况。</p>
<hr>
<h3 id="5-3-解构嵌套的结构体和枚举"><a href="#5-3-解构嵌套的结构体和枚举" class="headerlink" title="5.3 解构嵌套的结构体和枚举"></a>5.3 解构嵌套的结构体和枚举</h3><h3 id="示例代码：-5"><a href="#示例代码：-5" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Circle</span>(Point, <span class="type">i32</span>),</span><br><span class="line">    <span class="title function_ invoke__">Rectangle</span>(Point, Point),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">shape</span> = Shape::<span class="title function_ invoke__">Circle</span>(Point &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> shape &#123;</span><br><span class="line">        Shape::<span class="title function_ invoke__">Circle</span>(Point &#123; x, y &#125;, radius) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Circle at (&#123;&#125;, &#123;&#125;) with radius &#123;&#125;&quot;</span>, x, y, radius),</span><br><span class="line">        Shape::<span class="title function_ invoke__">Rectangle</span>(p1, p2) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Rectangle from (&#123;&#125;, &#123;&#125;) to (&#123;&#125;, &#123;&#125;)&quot;</span>, p1.x, p1.y, p2.x, p2.y),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析：-6"><a href="#解析：-6" class="headerlink" title="解析："></a>解析：</h3><p>在这个例子中，我们展示了如何解构嵌套的结构体和枚举。<code>Shape</code> 是一个包含 <code>Point</code> 结构体的枚举，通过 <code>match</code> 解构我们可以获取圆的中心和半径或矩形的两个点。</p>
<hr>
<h3 id="5-4-解构结构体和元组"><a href="#5-4-解构结构体和元组" class="headerlink" title="5.4 解构结构体和元组"></a>5.4 解构结构体和元组</h3><h3 id="示例代码：-6"><a href="#示例代码：-6" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">u8</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">person</span> = Person &#123;</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Alice&quot;</span>),</span><br><span class="line">        age: <span class="number">30</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (name, age) = (person.name, person.age);  <span class="comment">// 解构结构体和元组</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; is &#123;&#125; years old&quot;</span>, name, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析：-7"><a href="#解析：-7" class="headerlink" title="解析："></a>解析：</h3><p>这里将 <code>Person</code> 结构体解构成一个元组，并通过模式匹配将 <code>name</code> 和 <code>age</code> 解构出来。</p>
<hr>
<h3 id="5-5-解构数组"><a href="#5-5-解构数组" class="headerlink" title="5.5 解构数组"></a>5.5 解构数组</h3><h3 id="示例代码：-7"><a href="#示例代码：-7" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> arr &#123;</span><br><span class="line">        [<span class="number">1</span>, _, _] =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Starts with 1&quot;</span>),  <span class="comment">// 忽略数组的后两项</span></span><br><span class="line">        [a, b, c] =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Values are: &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, a, b, c),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析：-8"><a href="#解析：-8" class="headerlink" title="解析："></a>解析：</h3><p>这个例子展示了如何解构数组。我们通过模式匹配提取数组的元素，或者忽略特定位置的元素。</p>
<hr>
<h2 id="6-忽略模式中的值"><a href="#6-忽略模式中的值" class="headerlink" title="6. 忽略模式中的值"></a>6. 忽略模式中的值</h2><h3 id="6-1-使用-忽略整个值"><a href="#6-1-使用-忽略整个值" class="headerlink" title="6.1 使用 _ 忽略整个值"></a>6.1 使用 <code>_</code> 忽略整个值</h3><h3 id="示例代码：-8"><a href="#示例代码：-8" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_value</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> some_value &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(_) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Got a value, but don&#x27;t care what it is&quot;</span>),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Got no value&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析：-9"><a href="#解析：-9" class="headerlink" title="解析："></a>解析：</h3><p>使用 <code>_</code> 忽略整个值，表示我们只关心 <code>Some</code> 的存在，而不关心它包含的具体值。</p>
<hr>
<h3 id="6-2-使用嵌套的-忽略部分值"><a href="#6-2-使用嵌套的-忽略部分值" class="headerlink" title="6.2 使用嵌套的 _ 忽略部分值"></a>6.2 使用嵌套的 <code>_</code> 忽略部分值</h3><h3 id="示例代码：-9"><a href="#示例代码：-9" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (x, y, z) = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> (x, y, z) &#123;</span><br><span class="line">        (<span class="number">1</span>, _, <span class="number">3</span>) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Matched, ignoring y&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Not matched&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析：-10"><a href="#解析：-10" class="headerlink" title="解析："></a>解析：</h3><p>在这个例子中，我们通过嵌套的 <code>_</code> 来忽略元组中的 <code>y</code> 值，只匹配 <code>x</code> 和 <code>z</code>。</p>
<hr>
<h3 id="6-3-使用下划线开头忽略未使用的变量"><a href="#6-3-使用下划线开头忽略未使用的变量" class="headerlink" title="6.3 使用下划线开头忽略未使用的变量"></a>6.3 使用下划线开头忽略未使用的变量</h3><h3 id="示例代码：-10"><a href="#示例代码：-10" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_unused_var</span> = <span class="number">5</span>;  <span class="comment">// 下划线开头的变量不会引发编译器警告</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value is &#123;&#125;&quot;</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析：-11"><a href="#解析：-11" class="headerlink" title="解析："></a>解析：</h3><p>当你声明一个变量但不打算使用它时，可以在变量名前加下划线，避免编译器的警告。</p>
<hr>
<h3 id="6-4-用-忽略剩余值"><a href="#6-4-用-忽略剩余值" class="headerlink" title="6.4 用 .. 忽略剩余值"></a>6.4 用 <code>..</code> 忽略剩余值</h3><h3 id="示例代码：-11"><a href="#示例代码：-11" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = (<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> numbers &#123;</span><br><span class="line">        (first, .., last) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;First: &#123;&#125;, Last: &#123;&#125;&quot;</span>, first, last),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析：-12"><a href="#解析：-12" class="headerlink" title="解析："></a>解析：</h3><p><code>..</code> 可以用来忽略元组或数组中的中间值，保留我们关心的值（例如第一个和最后一个）。</p>
<hr>
<h2 id="7-匹配守卫提供的额外条件"><a href="#7-匹配守卫提供的额外条件" class="headerlink" title="7. 匹配守卫提供的额外条件"></a>7. 匹配守卫提供的额外条件</h2><h3 id="示例代码：-12"><a href="#示例代码：-12" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">Some</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(n) <span class="keyword">if</span> n &gt; <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Got a number greater than 2: &#123;&#125;&quot;</span>, n),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(n) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Got a number: &#123;&#125;&quot;</span>, n),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Got nothing&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析：-13"><a href="#解析：-13" class="headerlink" title="解析："></a>解析：</h3><p><code>if</code> 条件被称为匹配守卫，它允许在模式匹配的基础上再增加条件判断。这里我们只处理大于 2 的 <code>Some</code> 值。</p>
<hr>
<h2 id="8-绑定"><a href="#8-绑定" class="headerlink" title="8. @ 绑定"></a>8. <code>@</code> 绑定</h2><h3 id="示例代码：-13"><a href="#示例代码：-13" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        n @ <span class="number">1</span>..=<span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Matched and bound to &#123;&#125;&quot;</span>, n),  <span class="comment">// 将匹配的值绑定到 n</span></span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Not matched&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析：-14"><a href="#解析：-14" class="headerlink" title="解析："></a>解析：</h3><p><code>@</code> 绑定允许你在匹配的同时将值绑定到一个变量。这里 <code>n @ 1..=5</code> 表示不仅匹配 1 到 5 的范围，还将匹配的值绑定到变量 <code>n</code> 上。</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>Rust学习笔记</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust-模式匹配</title>
    <url>/2024/09/02/Rust-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h1><blockquote>
<p>模式匹配 ? 神tm的模式匹配 – 鲁迅</p>
</blockquote>
<h2 id="match"><a href="#match" class="headerlink" title="match"></a>match</h2><p><code>match</code>给我的感觉真的好像 <code>switch case</code> 语法:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt;  &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Lucky penny!&quot;</span>);</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然 match 本身也是一个表达式，因此可以用它来赋值：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">coin</span> = Coin::Quarter; </span><br><span class="line">    <span class="title function_ invoke__">value_in_cents</span>(coin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">coin_value</span> = <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">2</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Value: &#123;&#125;&quot;</span>, coin_value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>既然很像 <code>switch case</code> 语法， 那就必须要有 <code>default</code> 语句：<br><strong>当我们不想在匹配时列出所有值的时候，可以使用 Rust 提供的一个特殊模式</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt;  &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Lucky penny!&quot;</span>);</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        _ =&gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们只关心<code>Penny</code>和<code>Nickel</code>这几个值，不想列出其它的值。那么, 我们不必一个一个列出所有值, 因为可以使用特殊的模式 <code>_</code> 替代</p>
<h2 id="if-let-匹配"><a href="#if-let-匹配" class="headerlink" title="if let 匹配"></a>if let 匹配</h2><p>这个我感觉就是简单if语句，就不多加赘述：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="title function_ invoke__">Some</span>(<span class="number">3u8</span>);</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="number">3</span>) = v &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ps: 这两种匹配对于新手来说，可能有些难以抉择，但是只要记住一点就好：<strong>当你只要匹配一个条件，且忽略其他条件时就用 if let ，否则都用 match。</strong></p>
</blockquote>
<h2 id="matches-宏"><a href="#matches-宏" class="headerlink" title="matches!宏"></a>matches!宏</h2><p>Rust 标准库中提供了一个非常实用的宏：matches!，它可以将一个表达式跟模式进行匹配，然后返回匹配的结果 true or false。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">foo</span> = <span class="string">&#x27;f&#x27;</span>;</span><br><span class="line"><span class="built_in">assert!</span>(matches!(foo, <span class="string">&#x27;A&#x27;</span>..=<span class="string">&#x27;Z&#x27;</span> | <span class="string">&#x27;a&#x27;</span>..=<span class="string">&#x27;z&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">bar</span> = <span class="title function_ invoke__">Some</span>(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">assert!</span>(matches!(bar, <span class="title function_ invoke__">Some</span>(x) <span class="keyword">if</span> x &gt; <span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tips：小知识 无论是 match 还是 if let，这里都是一个新的代码块，而且这里的绑定相当于新变量，如果你使用同名变量，会发生变量遮蔽</p>
</blockquote>
]]></content>
      <categories>
        <category>Rust学习笔记</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust-流程控制</title>
    <url>/2024/08/29/Rust-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p><a href="https://practice-zh.course.rs/flow-control.html">https://practice-zh.course.rs/flow-control.html</a></p>
]]></content>
      <categories>
        <category>Rust学习笔记</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust-环境搭建</title>
    <url>/2024/08/19/Rust-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="Rust的优点"><a href="#Rust的优点" class="headerlink" title="Rust的优点"></a>Rust的优点</h1><p>Rust是由Mozilla主导开发的通用、编译型编程语言，设计准则为“安全、并发实用”，支持函数式、并发式、过程式以及面向对象的编程风格。</p>
<h2 id="内存安全"><a href="#内存安全" class="headerlink" title="内存安全"></a>内存安全</h2><ul>
<li>设计不允许空指针和悬空指针，指针只能透过固定的初始化形态来构建，而所有这些形态都要求1他们的输入已经分析过了</li>
<li>Rust有检查生命周期和指针冻结的系统，预防在C++中的许多类型错误，甚至是用了智能指针功能之后会发生的类错误</li>
</ul>
<h2 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h2><ul>
<li>编译译器必须在编译期知道我们所有变量的类型<ul>
<li>这不意味着你需要为每个变量指定类型，</li>
</ul>
</li>
<li>类型判断<ul>
<li>它可以根据变量的值和上下文中的使用方式来自动推导出变量的类型</li>
<li>在某些情况下，它无法推导出变量类型，需要手动去给予一个类型标注、</li>
</ul>
</li>
</ul>
<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><ul>
<li>Rust提供了强大的并发编程支持，使得开发者能够编写高效的多线程程序</li>
<li>通过其所有权系统和并发原语，Rust能够确保并发安全，并避免数据竞争和其他并发问题</li>
</ul>
<h1 id="为什么选择-Rust-？"><a href="#为什么选择-Rust-？" class="headerlink" title="为什么选择 Rust ？"></a>为什么选择 Rust ？</h1><ul>
<li>高性能<ul>
<li>Rust速度惊人且内存利用率极高。由于没有运行时和垃圾回收，它能够胜任对性能要求特别高的服务，可以在嵌入式设备上运行，还能轻松和其他语言集成。</li>
</ul>
</li>
<li>可靠性<ul>
<li>Rust 丰富的类型系统和所有权模型保证了内存安全和线程安全，让您在编译期就能够消除各种各样的错误。</li>
</ul>
</li>
<li>生产力<ul>
<li>Rust 拥有出色的文档、友好的编译器和清晰的错误提示信息， 还集成了一流的工具一包管理器和构建工具， 智能地自动补全和类型检验的多编辑器支持，以及自动格式化代码等等。</li>
</ul>
</li>
</ul>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li>window<ul>
<li><a href="https://www.rust-lang.org/zh-CN/tools/install">官网链接，自行下载</a></li>
<li>安装 Visual Studio 在安装时，确保选择 C++ 桌面开发 工作负载</li>
</ul>
</li>
<li>Windows 的 Linux 子系统（WSL）用户，要安装 Rust<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --proto&#x27;=https&#x27;--tlsv1.2 -sSf https://sh.rustup.rs lsh</span><br></pre></td></tr></table></figure>
当我们安装完成后，我们可以在我们的命令行中输入<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rustc --version</span><br></pre></td></tr></table></figure>
当界面上输出了如下内容，就说明我们安装没啥问题<br><img src="/../img/rustc_%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF.png" alt="版本信息"></li>
</ul>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>Rust 的升级非常频繁。如果您安装 Rustup 后已有一段时间，那么很可能您的 Rust 版本已经过时了。运行 <code>rustup update</code> 获取最新版本的 Rust。</p>
<h2 id="卸载-Rust"><a href="#卸载-Rust" class="headerlink" title="卸载 Rust"></a>卸载 Rust</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rustup self uninstall</span><br></pre></td></tr></table></figure>
<h2 id="查看离线文档"><a href="#查看离线文档" class="headerlink" title="查看离线文档"></a>查看离线文档</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rustup doc</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Rustup，它既是一个 Rust 安装器又是一个版本管理工具。</p>
</blockquote>
<h1 id="vscode-配置"><a href="#vscode-配置" class="headerlink" title="vscode 配置"></a>vscode 配置</h1><ul>
<li>rust-analyzer</li>
<li>Even Better TOML</li>
<li>crates</li>
</ul>
<h1 id="体验一下第一个程序"><a href="#体验一下第一个程序" class="headerlink" title="体验一下第一个程序"></a>体验一下第一个程序</h1><p>main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们执行 <code> rustc main.rs</code>, 编译后会生成一个main.exe文件，接着我们执行<code>./main</code><br><img src="/../img/hello-world.png" alt="输出截图">。</p>
<h2 id="预编译静态类型"><a href="#预编译静态类型" class="headerlink" title="预编译静态类型"></a>预编译静态类型</h2><p>上面的输出也引出了Rust的另一个概念，预编译静态类型语言，这意味着我们可以编译程序后发送给其他人，直接使用，他们甚至都不需要安装Rust就可以运行！</p>
<h1 id="Cargo"><a href="#Cargo" class="headerlink" title="Cargo"></a>Cargo</h1><p>Cargo是什么？ <span class="hide-inline"><button type="button" class="hide-button" style="background-color: #FF7242;color: #fff">查看答案
  </button><span class="hide-content">Rust 的构建工具和包管理器</span></span><br>在安装 Rustup 时，也会安装 Rust 构建工具和包管理器的最新稳定版，即 Cargo。Cargo 可以做很多事情</p>
<ul>
<li>cargo build 可以构建项目</li>
<li>cargo run 可以运行项目</li>
<li>cargo test 可以测试项目</li>
<li>cargo doc 可以为项目构建文档</li>
<li>cargo publish 可以将库发布到 crates.io。</li>
</ul>
<p>要检查是否安装了 Rust 和 Cargo，可以在终端中运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo --version</span><br></pre></td></tr></table></figure>
<h2 id="创建新项目"><a href="#创建新项目" class="headerlink" title="创建新项目"></a>创建新项目</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo new hello-rust</span><br></pre></td></tr></table></figure>
<p>这会生成一个名为 hello-rust 的新目录，其中包含以下文件：</p>
<p>hello-rust</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|- Cargo.toml</span><br><span class="line">    |- src</span><br><span class="line">        |- main.rs</span><br></pre></td></tr></table></figure>
<h3 id="Cargo-toml"><a href="#Cargo-toml" class="headerlink" title="Cargo.toml"></a>Cargo.toml</h3><p>Rust 的清单文件。其中包含了项目的元数据和依赖库。</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;hello-rust&quot;</span> // 项目名称</span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span> // 项目版本</span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span> // rust 版本</span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span> // 项目依赖</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="src"><a href="#src" class="headerlink" title="src"></a>src</h3><p>为编写应用代码的地方</p>
<h3 id="试试看运行"><a href="#试试看运行" class="headerlink" title="试试看运行"></a>试试看运行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo build</span><br></pre></td></tr></table></figure>
<p>他会生成一个target文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|- target</span><br><span class="line">    |- debug</span><br><span class="line">        |- hello-rust.exe（你的文件夹名称）</span><br></pre></td></tr></table></figure>
<p>当然我们也可以直接运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo run</span><br></pre></td></tr></table></figure>
<p>在一个命令内完成编译并运行</p>
<h3 id="发布构建"><a href="#发布构建" class="headerlink" title="发布构建"></a>发布构建</h3><p>当我们的项目准备好发布时，可以使用<code>cargo build --release</code>来优化编译项目</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo build --release</span><br></pre></td></tr></table></figure>
<p>这会在 <code>target/release</code> 而不是在 <code>target/debug</code> 下生成可执行文件。这些优化可以让Rust代码运行更快，不过这些优化也需要消耗更长的编译时间。</p>
<h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>我们在 Cargo.toml 文件中添加以下信息（从 crate 页面上获取）：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">ferris-says</span> = <span class="string">&quot;0.3.1&quot;</span></span><br></pre></td></tr></table></figure>
<p>接着运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo build</span><br></pre></td></tr></table></figure>
<p>…之后 Cargo 就会安装该依赖, 并且会创建一个新文件 Cargo.lock，该文件记录了本地所用依赖库的精确版本。</p>
<h3 id="升级依赖"><a href="#升级依赖" class="headerlink" title="升级依赖"></a>升级依赖</h3><p>我们可以通过<code>cargo update</code>进行依赖升级，当然这也是有些细节上的问题的。Cargo 升级依赖时候，会根据自己的规则进行版本升级，相信大家用过npm的都有些经验，这里就不赘述了！</p>
<h2 id="配置国内镜像"><a href="#配置国内镜像" class="headerlink" title="配置国内镜像"></a>配置国内镜像</h2><p>就和npm的淘宝镜像一样，cargo中的creates.io服务也需要设置一些镜像，方便我们安装</p>
<ul>
<li><a href="https://blog.csdn.net/ziqibit/article/details/135314246">cargo设置国内源 windows+linux</a></li>
</ul>
<h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><ul>
<li><a href="https://www.rust-lang.org/zh-CN/earn">官网</a></li>
<li><a href="https://doc.rust-lang.org/book/">《Rust 程序设计语言》</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/">《通过例子学 Rust》</a></li>
<li><a href="https://github.com/rust-lang/rustlings/">《Rustlings 课程》 </a></li>
</ul>
]]></content>
      <categories>
        <category>Rust学习笔记</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust-返回值和错误处理</title>
    <url>/2024/10/17/Rust-%E8%BF%94%E5%9B%9E%E5%80%BC%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="返回值和错误处理"><a href="#返回值和错误处理" class="headerlink" title="返回值和错误处理"></a>返回值和错误处理</h1><p>Rust 中的错误主要分为两类：</p>
<ul>
<li>可恢复错误<ul>
<li>通常用于从系统全局角度来看可以接受的错误<ul>
<li>例如处理用户的访问、操作等错误，这些错误只会影响某个用户自身的操作进程，而不会对系统的全局稳定性产生影响</li>
</ul>
</li>
<li>Result&lt;T, E&gt; 用于可恢复错误</li>
</ul>
</li>
<li>不可恢复错误<ul>
<li>该错误通常是全局性或者系统性的错误<ul>
<li>例如数组越界访问，系统启动时发生了影响启动流程的错误等等，这些错误的影响往往对于系统来说是致命的</li>
</ul>
</li>
<li>panic! 用于不可恢复错误</li>
</ul>
</li>
</ul>
<h2 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h2><p>在 Rust 中，panic! 宏用于引发运行时错误，导致程序崩溃。而在 <code>JavaScript</code> 中，<code>throw</code> 语句用于抛出异常，也可以导致程序的执行中断。</p>
<p>Rust:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;This is a panic message!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JavaScript:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throwError</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;This is an error message!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>but!<br>下面是一个关于 Rust 和 JavaScript 中错误处理的比较表：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Rust</th>
<th>JavaScript</th>
</tr>
</thead>
<tbody><tr>
<td>引发错误</td>
<td><code>panic!()</code></td>
<td><code>throw</code></td>
</tr>
<tr>
<td>作用</td>
<td>如果是 main 线程，则程序会终止，如果是其它子线程，该线程会终止，但是不会影响 main 线程</td>
<td>当前函数的执行将停止（throw 之后的语句不会被执行），并且控制权将传递给调用堆栈中第一个 catch 块。如果调用函数中没有 catch 块，则程序将终止</td>
</tr>
<tr>
<td>捕获机制</td>
<td>使用 <code>std::panic::catch_unwind</code></td>
<td>使用 <code>try...catch</code></td>
</tr>
<tr>
<td>默认行为</td>
<td>主线程 <code>panic</code> 会终止整个程序</td>
<td>未捕获的异常会终止整个程序</td>
</tr>
<tr>
<td>线程影响</td>
<td>仅终止发生 <code>panic</code> 的线程</td>
<td>终止当前执行上下文</td>
</tr>
</tbody></table>
<h3 id="何时该使用-panic-？"><a href="#何时该使用-panic-？" class="headerlink" title="何时该使用 panic! ？"></a>何时该使用 panic! ？</h3><p>在 Rust 中，应该在以下情况下使用 <code>panic!</code>：</p>
<ol>
<li><p><strong>不可恢复的错误</strong>：当程序遇到一个无法恢复的错误，比如逻辑错误、内部状态不一致或无法满足的条件时。</p>
</li>
<li><p><strong>断言失败</strong>：在调试时使用 <code>panic!</code> 来检查不应该发生的条件，例如使用 <code>assert!</code> 宏。</p>
</li>
<li><p><strong>程序状态异常</strong>：当程序的状态不符合预期且无法继续执行时。</p>
</li>
<li><p><strong>初始化失败</strong>：在构造函数或初始化代码中，如果遇到无法继续的情况，可以选择 <code>panic!</code>。</p>
</li>
</ol>
<p>在使用 <code>panic!</code> 时，确保这确实是最佳选择，因为它会导致程序终止，可能不适合所有场景。</p>
<h4 id="逻辑错误"><a href="#逻辑错误" class="headerlink" title="逻辑错误"></a>逻辑错误</h4><p>在某个逻辑条件下，如果遇到不应该发生的情况，可以使用 <code>panic!</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_element</span>(vec: &amp;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;, index: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> index &gt;= vec.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;Index out of bounds: &#123;&#125; is greater than or equal to &#123;&#125;&quot;</span>, index, vec.<span class="title function_ invoke__">len</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    vec[index]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="title function_ invoke__">get_element</span>(&amp;numbers, <span class="number">5</span>); <span class="comment">// 这里会导致 panic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p>在调试时，可以使用 <code>assert!</code> 来验证某个条件，如果条件不满足则触发 <code>panic!</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">check_positive</span>(num: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">assert!</span>(num &gt; <span class="number">0</span>, <span class="string">&quot;Number must be positive!&quot;</span>); <span class="comment">// 如果 num &lt;= 0，程序会 panic</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">check_positive</span>(<span class="number">5</span>); <span class="comment">// 这行正常执行</span></span><br><span class="line">    <span class="title function_ invoke__">check_positive</span>(-<span class="number">3</span>); <span class="comment">// 这里会导致 panic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="初始化失败"><a href="#初始化失败" class="headerlink" title="初始化失败"></a>初始化失败</h4><p>在构造某个结构体时，如果参数不合法，可以选择 <code>panic!</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">        <span class="keyword">if</span> username.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Username cannot be empty!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        User &#123; username &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user</span> = User::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Alice&quot;</span>.<span class="title function_ invoke__">to_string</span>()); <span class="comment">// 这行正常执行</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">invalid_user</span> = User::<span class="title function_ invoke__">new</span>(<span class="string">&quot;&quot;</span>.<span class="title function_ invoke__">to_string</span>()); <span class="comment">// 这里会导致 panic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之当启动时某个流程发生了错误，对后续代码的运行造成了影响，那么就应该使用 panic</p>
<h3 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h3><blockquote>
<p>当调用 panic! 宏时，它会</p>
</blockquote>
<blockquote>
<ol>
<li>格式化 panic 信息，然后使用该信息作为参数，调用 std::panic::panic_any() 函数</li>
<li>panic_any 会检查应用是否使用了 panic hook，如果使用了，该 hook 函数就会被调用（hook 是一个钩子函数，是外部代码设置的，用于在 panic 触发时，执行外部代码所需的功能）</li>
<li>当 hook 函数返回后，当前的线程就开始进行栈展开：从 panic_any 开始，如果寄存器或者栈因为某些原因信息错乱了，那很可能该展开会发生异常，最终线程会直接停止，展开也无法继续进行</li>
<li>展开的过程是一帧一帧的去回溯整个栈，每个帧的数据都会随之被丢弃，但是在展开过程中，你可能会遇到被用户标记为 catching 的帧（通过 std::panic::catch_unwind() 函数标记），此时用户提供的 catch 函数会被调用，展开也随之停止：当然，如果 catch 选择在内部调用 std::panic::resume_unwind() 函数，则展开还会继续。</li>
</ol>
</blockquote>
<blockquote>
<p>还有一种情况，在展开过程中，如果展开本身 panic 了，那展开线程会终止，展开也随之停止。</p>
</blockquote>
<blockquote>
<p>一旦线程展开被终止或者完成，最终的输出结果是取决于哪个线程 panic：</p>
<ul>
<li>对于 main 线程，操作系统提供的终止功能 core::intrinsics::abort() 会被调用，最终结束当前的 panic 进程；</li>
<li>如果是其它子线程，那么子线程就会简单的终止，同时信息会在稍后通过 std::thread::join() 进行收集。</li>
</ul>
</blockquote>
<h2 id="可恢复的错误-Result（更温和的错误处理方式）"><a href="#可恢复的错误-Result（更温和的错误处理方式）" class="headerlink" title="可恢复的错误 Result（更温和的错误处理方式）"></a>可恢复的错误 Result（更温和的错误处理方式）</h2><p><code>Result&lt;T, E&gt;</code>是一个枚举类型，定义如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>泛型参数 <code>T</code> 代表成功时存入的正确值的类型，存放方式是 <code>Ok(T)</code>，<code>E </code>代表错误时存入的错误值，存放方式是 <code>Err(E)</code>, 使用 <code>Result</code> 可以有效地管理错误情况而不导致程序崩溃。</p>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>下面是一个使用 <code>Result</code> 的示例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">divide</span>(x: <span class="type">f64</span>, y: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">f64</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> y == <span class="number">0.0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(<span class="string">&quot;Cannot divide by zero!&quot;</span>.<span class="title function_ invoke__">to_string</span>()) <span class="comment">// 返回错误</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(x / y) <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">divide</span>(<span class="number">10.0</span>, <span class="number">2.0</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(result) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, result), <span class="comment">// 处理成功情况</span></span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, e), <span class="comment">// 处理错误情况</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">divide</span>(<span class="number">10.0</span>, <span class="number">0.0</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(result) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, result),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, e), <span class="comment">// 捕获错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><ol>
<li><p><strong>函数定义</strong>：</p>
<ul>
<li><code>divide</code> 函数返回 <code>Result&lt;f64, String&gt;</code>，表示成功时返回 <code>f64</code> 类型的结果，失败时返回 <code>String</code> 类型的错误信息。</li>
</ul>
</li>
<li><p><strong>错误处理</strong>：</p>
<ul>
<li>在分母为零时，使用 <code>Err</code> 返回一个错误信息。</li>
<li>否则，使用 <code>Ok</code> 返回结果。</li>
</ul>
</li>
<li><p><strong>匹配结果</strong>：</p>
<ul>
<li>在 <code>main</code> 函数中，使用 <code>match</code> 来处理 <code>divide</code> 函数的返回值。</li>
<li>如果是 <code>Ok</code>，打印结果；如果是 <code>Err</code>，打印错误信息。</li>
</ul>
</li>
</ol>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul>
<li><strong>可读性</strong>：<code>Result</code> 明确了函数可能的返回状态，使代码更易于理解。</li>
<li><strong>错误传播</strong>：可以将错误传播到调用者，允许更高层次的错误处理。</li>
<li><strong>强类型</strong>：使用不同类型的错误信息（如 <code>String</code> 或自定义类型）来提供详细的上下文。</li>
</ul>
<p>通过 <code>Result</code>，Rust 提供了一种安全且灵活的错误处理机制，使开发者能够有效地处理潜在的错误而不必依赖于异常机制。</p>
<h3 id="unwrap-和-expect"><a href="#unwrap-和-expect" class="headerlink" title="unwrap 和 expect"></a>unwrap 和 expect</h3><p>在 Rust 中，<code>unwrap</code> 和 <code>expect</code> 是用于处理 <code>Option</code> 和 <code>Result</code> 类型的方法，它们可以快速获取值，但在遇到错误时会导致程序崩溃。</p>
<h4 id="unwrap"><a href="#unwrap" class="headerlink" title="unwrap"></a><code>unwrap</code></h4><ul>
<li><strong>功能</strong>：尝试获取 <code>Option</code> 或 <code>Result</code> 中的值。如果是 <code>Some</code> 或 <code>Ok</code>，返回值；如果是 <code>None</code> 或 <code>Err</code>，则触发 <code>panic!</code>。</li>
<li><strong>用法示例</strong>：</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_value</span> = <span class="title function_ invoke__">Some</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">value</span> = some_value.<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 返回 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">none_value</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="comment">// let value = none_value.unwrap(); // 这行会导致 panic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="expect"><a href="#expect" class="headerlink" title="expect"></a><code>expect</code></h4><ul>
<li><strong>功能</strong>：与 <code>unwrap</code> 类似，但可以自定义错误消息。适用于需要更详细错误信息的场景。</li>
<li><strong>用法示例</strong>：</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_value</span> = <span class="title function_ invoke__">Some</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">value</span> = some_value.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Expected a value but found None&quot;</span>); <span class="comment">// 返回 20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">none_value</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="comment">// let value = none_value.expect(&quot;Expected a value but found None&quot;); // 这行会导致 panic，并输出自定义消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li><strong>错误消息</strong>：<code>unwrap</code> 使用默认错误消息，而 <code>expect</code> 允许你提供自定义消息，这有助于调试时更好地了解错误原因。</li>
<li><strong>使用场景</strong>：在快速原型或测试中，<code>unwrap</code> 可能更方便，但在生产代码中，使用 <code>expect</code> 更能提供有意义的错误信息。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用 <code>unwrap</code> 和 <code>expect</code> 时需谨慎，确保在你确定值一定存在的情况下使用。否则，建议使用模式匹配或其他错误处理机制来安全地处理可能的错误情况。</p>
<h2 id="可选链（Optional-Chaining）"><a href="#可选链（Optional-Chaining）" class="headerlink" title="可选链（Optional Chaining）"></a>可选链（Optional Chaining）</h2><p>在 Rust 中，<strong>可选链（Optional Chaining）</strong> 通过 <code>?</code> 操作符来实现，它可以简化对 <code>Option</code> 或 <code>Result</code> 类型的错误处理。这个操作符可以在方法调用中自动处理 <code>None</code> 或 <code>Err</code> 的情况。</p>
<h3 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h3><p>以下是如何使用可选链的示例：</p>
<h4 id="Option-使用可选链"><a href="#Option-使用可选链" class="headerlink" title="Option 使用可选链"></a><code>Option</code> 使用可选链</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_length</span>(option: <span class="type">Option</span>&lt;&amp;<span class="type">str</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">usize</span>&gt; &#123;</span><br><span class="line">    option.<span class="title function_ invoke__">map</span>(|s| s.<span class="title function_ invoke__">len</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">length</span> = <span class="title function_ invoke__">get_length</span>(some_string); <span class="comment">// Some(5)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">none_string</span>: <span class="type">Option</span>&lt;&amp;<span class="type">str</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">length_none</span> = <span class="title function_ invoke__">get_length</span>(none_string); <span class="comment">// None</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;, &#123;:?&#125;&quot;</span>, length, length_none);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Result-使用可选链"><a href="#Result-使用可选链" class="headerlink" title="Result 使用可选链"></a><code>Result</code> 使用可选链</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">divide</span>(x: <span class="type">f64</span>, y: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">f64</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> y == <span class="number">0.0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(<span class="string">&quot;Cannot divide by zero!&quot;</span>.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(x / y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">f64</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">divide</span>(<span class="number">10.0</span>, <span class="number">2.0</span>)?; <span class="comment">// 使用 `?`，如果是 Err，直接返回</span></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(result * <span class="number">2.0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">calculate</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(value) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, value),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, e),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">divide</span>(<span class="number">10.0</span>, <span class="number">0.0</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(value) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, value),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, e), <span class="comment">// 处理错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h3><ol>
<li><p><strong>对 <code>Option</code> 的使用</strong>：</p>
<ul>
<li>使用 <code>map</code> 方法处理 <code>Option</code> 中的值，若是 <code>None</code>，则返回 <code>None</code>，否则返回 <code>Some</code>。</li>
</ul>
</li>
<li><p><strong>对 <code>Result</code> 的使用</strong>：</p>
<ul>
<li>使用 <code>?</code> 操作符来简化错误处理。如果 <code>divide</code> 返回 <code>Err</code>，<code>calculate</code> 将立即返回这个错误；如果是 <code>Ok</code>，则继续执行。</li>
</ul>
</li>
</ol>
<h3 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h3><ul>
<li><strong>简化代码</strong>：可选链减少了冗长的 <code>if let</code> 或 <code>match</code> 语句，使代码更简洁。</li>
<li><strong>提高可读性</strong>：使用 <code>?</code> 可以直观地显示出函数的错误传播逻辑。</li>
</ul>
<p>可选链是 Rust 中处理可选值和错误的一种强大工具，可以有效提升代码的简洁性和可读性。</p>
]]></content>
      <categories>
        <category>Rust学习笔记</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust-进阶-智能指针概述&amp;box指针</title>
    <url>/2024/08/29/Rust-%E8%BF%9B%E9%98%B6-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%A6%82%E8%BF%B0&amp;box%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>智能指针是一类数据结构：</p>
<ul>
<li>指针</li>
<li>额外的元数据</li>
<li>附加的功能</li>
</ul>
<p>与普通指针不同，智能指针在Rust中实现了 Deref 和 Drop 两个 trait，这使得他们可以像指针一样解引用并在离开作用域时自动清理资源。</p>
<h2 id="为什么存在智能指针？"><a href="#为什么存在智能指针？" class="headerlink" title="为什么存在智能指针？"></a>为什么存在智能指针？</h2><ul>
<li>资源管理<ul>
<li>自动管理资源的分配和释放，避免内存泄漏</li>
</ul>
</li>
<li>所有权与借用<ul>
<li>Rust的所有权系统通过智能指针来确保内存安全，避免数据竞争和悬垂指针</li>
</ul>
</li>
<li>复杂数据结构<ul>
<li>通过智能指针可以构建复杂的数据结构<ul>
<li>递归结构</li>
<li>共享数据等</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="智能指针特性"><a href="#智能指针特性" class="headerlink" title="智能指针特性"></a>智能指针特性</h3><ul>
<li>Deref <ul>
<li>实现了 Deref 的类型可以像常规引用一样使用 * 运算符解引用</li>
<li>例如<ul>
<li><code>Box&lt;T&gt;</code> 实现了 Deref，所以可以通过 * 解引用获取器内部数据</li>
</ul>
</li>
</ul>
</li>
<li>Drop<ul>
<li>实现了 Deref 的类型在离开作用域的时候会自动调用其 drop 方法，用于释放资源</li>
<li>例如<ul>
<li><code>Box&lt;T&gt;</code> 在超出作用域时会自动释放堆内存</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Box"><a href="#Box" class="headerlink" title="Box"></a>Box<T></h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><code>Box&lt;T&gt;</code> 将类型T的值分配到堆上，而不是栈上。当Box被销毁时，对上的数据也会被销毁。</p>
<h4 id="Box的底层实现"><a href="#Box的底层实现" class="headerlink" title="Box的底层实现"></a>Box的底层实现</h4><ul>
<li>底层原理<ul>
<li><code>Box&lt;T&gt;</code> 实际上是一个智能指针，内部保护管指向堆上分配内存的裸指针。</li>
<li>当 <code>Box&lt;T&gt;</code> 被销毁时， 其Drop trait 会被调用，释放堆上的内存。</li>
</ul>
</li>
<li>内存分配<ul>
<li>Rust 使用系统的全局分配器来管理堆内存。</li>
<li>Box::new 分配内存， Drop 释放内存。</li>
</ul>
</li>
<li>安全性<ul>
<li>Rust 的所有权系统确保<code>Box&lt;T&gt;</code>的内存安全，所有权转移时，堆内存的生命周期也会随之改变。</li>
</ul>
</li>
</ul>
<h4 id="Box的使用场景"><a href="#Box的使用场景" class="headerlink" title="Box的使用场景"></a>Box的使用场景</h4><ol>
<li><p>堆分配<br>Box 最常见的用途是将数据分配在堆上，而不是栈上。这在处理：</p>
<ul>
<li>较大数据结构</li>
<li>数据结构的大小在编译时不确定<br>以上两种情况下尤为重要。</li>
</ul>
</li>
<li><p>动态大小类型<br>Box 允许处理动态大小类型：<br> 如：str 和 [T]</p>
</li>
<li><p>递归数据解构<br>递归数据需要指针类型来引用自身，而Box提供了这一功能</p>
</li>
<li><p>数据擦除<br><code>Box&lt;dyn Trait&gt;</code>用于类型擦除，允许在运行时觉得类型。 </p>
<ul>
<li>dyn 关键字用于指定动态分发的类型。它运行在运行时决定具体类型。在Rustzhon1, dyn关键字用于实现动态方法的 trait 对象。</li>
</ul>
</li>
<li><p>内存管理和性能优化<br>通过使用 Box，可以控制内存的分配和释放，从而优化性能和内存使用。</p>
<ul>
<li>如：将大型数据结构放在对上，而不是在栈上，可以减少栈的使用量，从而避免栈溢出。</li>
</ul>
</li>
</ol>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li>优点<ul>
<li>提供堆内存分配，支持复杂数据结构</li>
<li>与 Rust 所有权系统完美集成，确保内存安全</li>
<li>动态分配对象，实现类型擦除</li>
</ul>
</li>
<li>缺点<ul>
<li>需要堆内存分配和释放，可能带来性能开销</li>
<li>不适合需要频繁分配和释放的场景</li>
</ul>
</li>
</ul>
<h3 id="Drop、Deref和DerefMut"><a href="#Drop、Deref和DerefMut" class="headerlink" title="Drop、Deref和DerefMut"></a>Drop、Deref和DerefMut</h3><ul>
<li>Drop Trait<ul>
<li>当一个值离开作用域时应该执行的操作<ul>
<li>例如︰Box<T>在超出作用域时会自动调用其Droptrait，释放堆上的内存</li>
</ul>
</li>
<li>如何将一个类型转换为引用。<ul>
<li>例如∶Box<T>实现了Deref，所以可以通过*运算符解引用获取其内部数据</li>
</ul>
</li>
<li>当值离开作用域时执行的代码，通常用于释放资源（例如内存、文件句柄、网络连接等）。<ul>
<li>定义了一个drop方法，当值被释放时，Rust会自动调用这个方法</li>
</ul>
</li>
<li>重载解引用运算符(*)。它允许你定义自定义指针类型的解引用行为<ul>
<li>定义了一个deref方法，该方法返回指向目标类型的引用</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Rust学习笔记</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust-闭包</title>
    <url>/2024/11/19/Rust-%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h1 id="Rust-闭包"><a href="#Rust-闭包" class="headerlink" title="Rust-闭包"></a>Rust-闭包</h1><p>在 Rust 中，闭包（closure）是一个非常重要的概念，它使得 Rust 的函数式编程特性得以实现。闭包允许你在函数内部定义并捕获外部环境中的变量，它是匿名的函数体，且通常以更简洁的方式进行声明和使用。</p>
<h2 id="1-闭包基本语法"><a href="#1-闭包基本语法" class="headerlink" title="1. 闭包基本语法"></a>1. 闭包基本语法</h2><p>闭包的基本语法可以通过 <code>|参数| &#123; 函数体 &#125;</code> 的形式定义。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">add</span> = |x, y| x + y;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">add</span>(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 输出 3</span></span><br></pre></td></tr></table></figure>

<h2 id="2-捕获外部变量"><a href="#2-捕获外部变量" class="headerlink" title="2. 捕获外部变量"></a>2. 捕获外部变量</h2><p>闭包与普通函数的一个重要区别是它们可以捕获外部环境中的变量。Rust 会根据闭包如何使用外部变量来决定它如何捕获这些变量（按引用、按可变引用或按值）。</p>
<ul>
<li><strong>按引用捕获</strong>：如果闭包只读取外部变量的值，Rust 会自动按引用捕获变量。</li>
<li><strong>按可变引用捕获</strong>：如果闭包需要修改外部变量的值，Rust 会按可变引用捕获变量。</li>
<li><strong>按值捕获</strong>：如果闭包转移了外部变量的所有权，它会按值捕获该变量。</li>
</ul>
<h2 id="3-闭包与函数的区别"><a href="#3-闭包与函数的区别" class="headerlink" title="3. 闭包与函数的区别"></a>3. 闭包与函数的区别</h2><p>函数和闭包的一个主要区别是，函数的参数和返回类型在编译时就确定了，而闭包的类型是在运行时确定的。闭包的类型是匿名的，Rust 编译器会根据闭包的使用方式推导出闭包的类型。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">apply</span>&lt;F&gt;(f: F) <span class="keyword">where</span> F: <span class="title function_ invoke__">FnOnce</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">closure</span> = || <span class="built_in">println!</span>(<span class="string">&quot;x is &#123;&#125;&quot;</span>, x);</span><br><span class="line"><span class="title function_ invoke__">apply</span>(closure);</span><br></pre></td></tr></table></figure>

<h2 id="4-闭包类型"><a href="#4-闭包类型" class="headerlink" title="4. 闭包类型"></a>4. 闭包类型</h2><p>闭包类型分为三类：<code>Fn</code>, <code>FnMut</code>, 和 <code>FnOnce</code>，它们根据闭包如何捕获和使用外部变量来分类：</p>
<ul>
<li>**<code>Fn</code>**：闭包捕获外部变量的引用，且不修改它们。适用于多次调用。</li>
<li>**<code>FnMut</code>**：闭包捕获外部变量的可变引用，且可以修改它们。适用于多次调用但可能改变外部变量。</li>
<li>**<code>FnOnce</code>**：闭包捕获外部变量的所有权，一旦调用就不能再使用外部变量。适用于只调用一次的场景。</li>
</ul>
<h2 id="5-闭包的生命周期"><a href="#5-闭包的生命周期" class="headerlink" title="5. 闭包的生命周期"></a>5. 闭包的生命周期</h2><p>闭包可以延长捕获的变量的生命周期，尤其是在使用 <code>FnOnce</code> 时，闭包本身就会占用外部变量的所有权，从而可能影响变量的生命周期。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">c</span> = <span class="keyword">move</span> || <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// `move` 强制捕获 s 的所有权</span></span><br><span class="line"><span class="title function_ invoke__">c</span>(); <span class="comment">// 之后不能再使用 `s`</span></span><br></pre></td></tr></table></figure>

<h2 id="6-使用-move-关键字"><a href="#6-使用-move-关键字" class="headerlink" title="6. 使用 move 关键字"></a>6. 使用 <code>move</code> 关键字</h2><p><code>move</code> 关键字会强制闭包捕获变量的所有权，而不是按引用捕获。它对于多线程编程尤为重要，因为它确保了闭包能够在另一个线程中安全使用。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">c</span> = <span class="keyword">move</span> || <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// `move` 将 `s` 的所有权转移给闭包</span></span><br><span class="line"><span class="title function_ invoke__">c</span>();</span><br></pre></td></tr></table></figure>

<h2 id="7-闭包作为函数参数"><a href="#7-闭包作为函数参数" class="headerlink" title="7. 闭包作为函数参数"></a>7. 闭包作为函数参数</h2><p>闭包可以作为函数的参数传递。通过泛型，Rust 允许我们将闭包作为参数，并根据闭包的签名来进行限制。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">apply</span>&lt;F&gt;(f: F) <span class="keyword">where</span> F: <span class="title function_ invoke__">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">f</span>(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">closure</span> = |x| x + <span class="number">1</span>;</span><br><span class="line"><span class="title function_ invoke__">apply</span>(closure); <span class="comment">// 输出 3</span></span><br></pre></td></tr></table></figure>

<h2 id="8-闭包与-Iterator-的结合"><a href="#8-闭包与-Iterator-的结合" class="headerlink" title="8. 闭包与 Iterator 的结合"></a>8. 闭包与 <code>Iterator</code> 的结合</h2><p>闭包常常与 <code>Iterator</code> 结合使用来实现链式调用。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">result</span>: <span class="type">Vec</span>&lt;_&gt; = numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|&amp;x| x * <span class="number">2</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, result); <span class="comment">// 输出 [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure>

<h2 id="9-性能和优化"><a href="#9-性能和优化" class="headerlink" title="9. 性能和优化"></a>9. 性能和优化</h2><p>Rust 在闭包的实现上进行了一些优化，特别是在闭包的类型推导方面。由于闭包的类型在编译时是可以推导的，Rust 能够避免不必要的动态分发，从而提高性能。</p>
<h2 id="10-闭包与多线程"><a href="#10-闭包与多线程" class="headerlink" title="10. 闭包与多线程"></a>10. 闭包与多线程</h2><p>闭包与多线程结合时，使用 <code>move</code> 关键字非常重要。它确保了闭包能够将其捕获的外部变量的所有权转移到线程中，避免了引用问题。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// `s` 的所有权被转移到线程中</span></span><br><span class="line">&#125;);</span><br><span class="line">handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>闭包</strong>是 Rust 中的一个强大工具，能够捕获并操作外部环境的变量。</li>
<li><strong>闭包类型</strong>：<code>Fn</code>, <code>FnMut</code>, 和 <code>FnOnce</code> 分别表示不同的捕获方式。</li>
<li><strong><code>move</code> 关键字</strong>：强制闭包捕获变量的所有权，常用于多线程编程。</li>
<li><strong>闭包的生命周期</strong>：通过闭包捕获的变量生命周期可能会延长或改变。</li>
<li><strong>闭包的性能优化</strong>：Rust 在闭包的类型推导和内存管理上进行了优化，避免了运行时的性能损失。</li>
</ul>
<p>通过理解闭包的这些特性，你可以在 Rust 中更灵活地使用闭包来实现更加简洁、功能强大的代码。</p>
<h1 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h1><p>假设你在开覆盖博客系统，其中每个用户都可以查询不用的文章页面，为了优化性能，你决定在服务端实现一个缓存系统：</p>
<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><ol>
<li>实现<code>PageCache</code>结构体</li>
<li>该结构体应缓存用户id和文章id渲染的页面<ul>
<li>你需要为该结构体实现一个 <code>get_page</code> 方法，该方法接受用户id+文章id,并返回渲染后的页面内容</li>
<li>如果相同的用户id和文章id已经渲染过，<code>get_page</code>方法应该直接返回缓存的页面，而不是重新渲染</li>
</ul>
</li>
<li><code>PageCache</code>应支持任意类型的用户id和文章id（u32 or string）</li>
<li>缓存的内容应该为渲染后的html页面（String类型）</li>
</ol>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">use</span> std::hash::Hash;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 PageCache 结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PageCache</span>&lt;U, A&gt; &#123;</span><br><span class="line">    cache: HashMap&lt;(U, A), <span class="type">String</span>&gt;, <span class="comment">// 缓存的内容是 (用户id, 文章id) -&gt; 渲染后的页面内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;U, A&gt; PageCache&lt;U, A&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    U: <span class="built_in">Eq</span> + Hash + <span class="built_in">Clone</span>, <span class="comment">// 用户id必须实现Eq、Hash和Clone</span></span><br><span class="line">    A: <span class="built_in">Eq</span> + Hash + <span class="built_in">Clone</span>, <span class="comment">// 文章id也必须实现Eq、Hash和Clone</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建一个新的 PageCache</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        PageCache &#123;</span><br><span class="line">            cache: HashMap::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取缓存的页面，或者渲染并返回新页面</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_page</span>&lt;F&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, user_id: &amp;U, article_id: &amp;A, render_fn: F) <span class="punctuation">-&gt;</span> <span class="type">String</span></span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="title function_ invoke__">Fn</span>(&amp;U, &amp;A) <span class="punctuation">-&gt;</span> <span class="type">String</span>, <span class="comment">// render_fn是一个函数，接受引用类型的用户id和文章id，返回渲染后的页面内容</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 查找缓存：使用clone确保不会移动引用</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(page) = <span class="keyword">self</span>.cache.<span class="title function_ invoke__">get</span>(&amp;(user_id.<span class="title function_ invoke__">clone</span>(), article_id.<span class="title function_ invoke__">clone</span>())) &#123;</span><br><span class="line">            <span class="keyword">return</span> page.<span class="title function_ invoke__">clone</span>(); <span class="comment">// 如果缓存命中，直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果缓存没有命中，调用render_fn渲染页面</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">rendered_page</span> = <span class="title function_ invoke__">render_fn</span>(user_id, article_id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将渲染后的页面存入缓存</span></span><br><span class="line">        <span class="keyword">self</span>.cache.<span class="title function_ invoke__">insert</span>((user_id.<span class="title function_ invoke__">clone</span>(), article_id.<span class="title function_ invoke__">clone</span>()), rendered_page.<span class="title function_ invoke__">clone</span>());</span><br><span class="line"></span><br><span class="line">        rendered_page <span class="comment">// 返回渲染后的页面</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟页面渲染的函数</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">render_page</span>(user_id: &amp;<span class="type">u32</span>, article_id: &amp;<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">&quot;&lt;html&gt;&lt;body&gt;User &#123;&#125; viewing Article &#123;&#125;: Rendered content&lt;/body&gt;&lt;/html&gt;&quot;</span>, user_id, article_id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建一个 PageCache 实例</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">page_cache</span> = PageCache::&lt;<span class="type">u32</span>, <span class="type">u32</span>&gt;::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟获取页面</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">page1</span> = page_cache.<span class="title function_ invoke__">get_page</span>(&amp;<span class="number">1</span>, &amp;<span class="number">101</span>, render_page);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, page1); <span class="comment">// 渲染并输出页面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次请求相同的页面，应直接返回缓存内容</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">page2</span> = page_cache.<span class="title function_ invoke__">get_page</span>(&amp;<span class="number">1</span>, &amp;<span class="number">101</span>, render_page);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, page2); <span class="comment">// 应该输出与上面相同的内容，且不重新渲染</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Rust学习笔记</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust进阶- 迭代器&amp;关联类型</title>
    <url>/2024/11/24/Rust%E8%BF%9B%E9%98%B6-%20%E8%BF%AD%E4%BB%A3%E5%99%A8&amp;%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="1-迭代器（Iterators）"><a href="#1-迭代器（Iterators）" class="headerlink" title="1. 迭代器（Iterators）"></a>1. 迭代器（Iterators）</h3><p>在 Rust 中，迭代器是实现了 <code>Iterator</code> trait 的类型，主要用于逐个处理集合中的元素。迭代器的核心是 <code>next()</code> 方法，它返回 <code>Option&lt;T&gt;</code> 类型的结果，表示迭代器的下一个元素。每次调用 <code>next()</code>，迭代器返回一个 <code>Some(T)</code>，如果没有更多的元素，则返回 <code>None</code>。</p>
<h4 id="创建迭代器"><a href="#创建迭代器" class="headerlink" title="创建迭代器"></a>创建迭代器</h4><p>Rust 中的集合类型（如 <code>Vec</code>、<code>Array</code>、<code>HashMap</code> 等）都实现了 <code>IntoIterator</code> trait，因此可以很容易地创建迭代器。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 into_iter() 创建一个迭代器</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = vec.<span class="title function_ invoke__">into_iter</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">1</span>)); <span class="comment">// 获取第一个元素</span></span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">2</span>)); <span class="comment">// 获取第二个元素</span></span><br></pre></td></tr></table></figure>

<h4 id="常用的迭代器方法"><a href="#常用的迭代器方法" class="headerlink" title="常用的迭代器方法"></a>常用的迭代器方法</h4><p>Rust 提供了许多用于操作迭代器的方法，常见的有：</p>
<ul>
<li><code>map</code>: 对每个元素应用一个函数，返回新的迭代器。</li>
<li><code>filter</code>: 过滤出符合条件的元素。</li>
<li><code>fold</code>: 将所有元素通过一个累加函数“折叠”成一个值。</li>
<li><code>collect</code>: 将迭代器转换成其他集合类型（如 <code>Vec</code>、<code>HashMap</code>）。</li>
</ul>
<p>示例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 map 将每个元素乘以 2</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">doubled</span>: <span class="type">Vec</span>&lt;_&gt; = numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|&amp;x| x * <span class="number">2</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, doubled); <span class="comment">// [2, 4, 6, 8, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 filter 过滤出大于 2 的元素</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">filtered</span>: <span class="type">Vec</span>&lt;_&gt; = numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">filter</span>(|&amp;&amp;x| x &gt; <span class="number">2</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, filtered); <span class="comment">// [3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<h3 id="2-关联类型（Associated-Types）"><a href="#2-关联类型（Associated-Types）" class="headerlink" title="2. 关联类型（Associated Types）"></a>2. 关联类型（Associated Types）</h3><p>关联类型是 Rust 中的一种高级特性，允许你在 trait 中定义类型参数，这些类型参数与 trait 的实现相关。关联类型可以让你在不指定具体类型的情况下定义行为，从而提供更强的灵活性。</p>
<h4 id="关联类型的语法"><a href="#关联类型的语法" class="headerlink" title="关联类型的语法"></a>关联类型的语法</h4><p>你可以在 trait 中声明一个关联类型，并在实现这个 trait 时指定该类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个 trait，其中 T 是关联类型</span></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;  <span class="comment">// 关联类型 Output</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现这个 trait</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    radius: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Shape</span> <span class="keyword">for</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="type">f64</span>;  <span class="comment">// 关联类型 Output 为 f64</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output &#123;</span><br><span class="line">        std::<span class="type">f64</span>::consts::PI * <span class="keyword">self</span>.radius * <span class="keyword">self</span>.radius</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>Shape</code> trait 中定义了一个关联类型 <code>Output</code>，它代表了一个形状的面积类型。对于 <code>Circle</code> 类型，我们实现了 <code>area()</code> 方法，并指定 <code>Output</code> 类型为 <code>f64</code>。</p>
<h4 id="关联类型的应用"><a href="#关联类型的应用" class="headerlink" title="关联类型的应用"></a>关联类型的应用</h4><p>关联类型特别适用于构建库和框架时，它们可以帮助你定义更抽象和灵活的接口。例如，在 Rust 标准库中，<code>Iterator</code> trait 就使用了关联类型来简化迭代器的实现。</p>
<p><code>Iterator</code> trait 定义如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>; <span class="comment">// 关联类型 Item，用来表示每次迭代的元素类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实现自定义迭代器时，你需要指定 <code>Item</code> 类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    count: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">usize</span>;  <span class="comment">// 定义迭代器的元素类型为 usize</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.count &lt;= <span class="number">5</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.count)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = Counter &#123; count: <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>迭代器</strong>是 Rust 中非常强大且灵活的工具，提供了对集合的顺序遍历能力。你可以通过多种方法对迭代器进行转换、过滤、映射等操作。</li>
<li><strong>关联类型</strong>允许在 trait 中定义与实现相关的类型，它提高了代码的灵活性和抽象度，特别适用于创建通用库和框架。</li>
</ul>
<p>理解并掌握这两个特性后，你将能够写出更加高效、优雅的 Rust 代码。</p>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p>请你实现一个自定义迭代器，用于生成斐波那契数列。你的迭代器应该支持无限生成斐波那契树，知道用户停止迭代。</p>
<h3 id="任务要求："><a href="#任务要求：" class="headerlink" title="任务要求："></a>任务要求：</h3><ul>
<li>实现一个结构体Fibonacci，并为它实现 Iterator trait</li>
<li>在next方法中生成下一个斐波那契数</li>
<li>编写一个测试函数，输入用户指定数目的斐波那契数</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line">    a: <span class="type">u64</span>,</span><br><span class="line">    b: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line">    <span class="comment">// 创建 Fibonacci 迭代器</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Fibonacci &#123; a: <span class="number">0</span>, b: <span class="number">1</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">u64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">next_value</span> = <span class="keyword">self</span>.a;</span><br><span class="line">        <span class="keyword">self</span>.a = <span class="keyword">self</span>.b;</span><br><span class="line">        <span class="keyword">self</span>.b = <span class="keyword">self</span>.b + next_value;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(next_value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试函数，打印前 `n` 个斐波那契数</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_fibonacci</span>(n: <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">fibonacci</span> = Fibonacci::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span>: <span class="type">Vec</span>&lt;<span class="type">u64</span>&gt; = fibonacci.<span class="title function_ invoke__">take</span>(n).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 用户指定生成前 10 个斐波那契数</span></span><br><span class="line">    <span class="title function_ invoke__">print_fibonacci</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 用户指定生成前 20 个斐波那契数</span></span><br><span class="line">    <span class="title function_ invoke__">print_fibonacci</span>(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Rust学习笔记</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust进阶： 并发 - 概念、线程、通信</title>
    <url>/2024/11/30/Rust%E8%BF%9B%E9%98%B6%EF%BC%9A%20%E5%B9%B6%E5%8F%91%20-%20%E6%A6%82%E5%BF%B5%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h1 id="Rust进阶：-并发-概念、线程、通信"><a href="#Rust进阶：-并发-概念、线程、通信" class="headerlink" title="Rust进阶： 并发 - 概念、线程、通信"></a>Rust进阶： 并发 - 概念、线程、通信</h1><p>Rust 在并发编程方面提供了很多独特的特性，使得编写安全且高效的并发程序成为可能。</p>
<h2 id="1-并发编程的概念"><a href="#1-并发编程的概念" class="headerlink" title="1. 并发编程的概念"></a>1. <strong>并发编程的概念</strong></h2><p>并发（Concurrency）是指程序的执行可以在多个任务之间交替进行。与并行（Parallelism）不同，并行意味着任务可以同时运行，而并发则侧重于任务的调度和管理。</p>
<p>在 Rust 中，并发编程强调以下几个原则：</p>
<ul>
<li><strong>内存安全</strong>：Rust 的所有权系统（Ownership）和借用检查器（Borrow Checker）确保了数据在并发环境中的安全访问。</li>
<li><strong>无数据竞争</strong>：通过所有权和借用规则，Rust 防止了数据竞争（Data Race）。当数据被共享时，Rust 确保不会同时被多个线程修改。</li>
</ul>
<h2 id="2-Rust-中的线程"><a href="#2-Rust-中的线程" class="headerlink" title="2. Rust 中的线程"></a>2. <strong>Rust 中的线程</strong></h2><p>Rust 提供了标准库中的 <code>std::thread</code> 模块来处理多线程操作。</p>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>通过 <code>std::thread::spawn</code> 可以创建一个新的线程来执行一个闭包：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Hello from a new thread!&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程完成</span></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>thread::spawn</code> 接受一个闭包并启动一个新的线程，线程执行完毕后返回一个 <code>JoinHandle</code>。</li>
<li><code>join</code> 方法用来阻塞当前线程，等待新线程完成。</li>
</ul>
<h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p>每个线程都有一个生命周期，在 Rust 中，由于其内存安全特性，如果在主线程退出前，线程仍在执行并且没有被显式加入 <code>join</code>，Rust 会强制保证线程的结束。</p>
<h2 id="3-线程间通信"><a href="#3-线程间通信" class="headerlink" title="3. 线程间通信"></a>3. <strong>线程间通信</strong></h2><p>Rust 提供了几种线程间通信的方式，最常用的是通过 <strong>通道（Channel）</strong> 来实现数据的传递。</p>
<h3 id="使用通道（Channel）"><a href="#使用通道（Channel）" class="headerlink" title="使用通道（Channel）"></a>使用通道（Channel）</h3><p>通道在 Rust 中通过 <code>std::sync::mpsc</code> 提供。通道可以实现线程之间的消息传递，类似于其他语言中的消息队列。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建通道</span></span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动线程，发送消息</span></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(<span class="string">&quot;Hello from the thread!&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收消息</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">message</span> = rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Received: &#123;&#125;&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>mpsc::channel</code> 返回一个发送者（<code>tx</code>）和接收者（<code>rx</code>）。</li>
<li>发送者可以发送消息，接收者可以接收消息。这里的消息传递是阻塞的，即接收者会等待直到消息到达。</li>
</ul>
<h3 id="通道的特点"><a href="#通道的特点" class="headerlink" title="通道的特点"></a>通道的特点</h3><ul>
<li><strong>发送者和接收者</strong>：一个通道可以有多个发送者（<code>tx</code>）和一个接收者（<code>rx</code>），这是通过使用多生产者单消费者（MPSC）的模式来实现的。</li>
<li><strong>线程安全</strong>：<code>mpsc::channel</code> 提供了线程安全的消息传递机制，不需要额外的同步机制。</li>
</ul>
<h2 id="4-共享内存的同步"><a href="#4-共享内存的同步" class="headerlink" title="4. 共享内存的同步"></a>4. <strong>共享内存的同步</strong></h2><p>除了使用通道，Rust 还通过 <code>std::sync::Arc</code> 和 <code>std::sync::Mutex</code> 提供了另一种共享内存的方式，适用于多个线程需要访问共享数据的场景。</p>
<h3 id="使用-Arc-和-Mutex"><a href="#使用-Arc-和-Mutex" class="headerlink" title="使用 Arc 和 Mutex"></a>使用 <code>Arc</code> 和 <code>Mutex</code></h3><ul>
<li><code>Arc</code>（Atomic Reference Counting）用于在多个线程之间共享所有权。</li>
<li><code>Mutex</code>（互斥锁）用于在同一时间只允许一个线程访问数据。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Arc&lt;Mutex&lt;T&gt;&gt;</code> 允许多个线程安全地访问同一数据（<code>T</code>），同时 <code>Mutex</code> 保证一次只有一个线程可以访问数据。</li>
<li><code>lock</code> 会阻塞直到锁可用。</li>
</ul>
<h2 id="5-Rust-的并发模型的优势"><a href="#5-Rust-的并发模型的优势" class="headerlink" title="5. Rust 的并发模型的优势"></a>5. <strong>Rust 的并发模型的优势</strong></h2><p>Rust 的并发编程模型有几个显著的优势：</p>
<ul>
<li><strong>无数据竞争</strong>：Rust 的所有权系统确保在并发环境下不会发生数据竞争，即使是多个线程也能安全地共享数据。</li>
<li><strong>内存安全性</strong>：Rust 强制要求明确的所有权和生命周期，这在编译时就能捕捉到错误，从而避免了运行时的内存错误。</li>
<li><strong>高效性能</strong>：Rust 的零成本抽象（zero-cost abstractions）意味着并发代码不会比串行代码性能差。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Rust 的并发模型与其他语言的并发编程有所不同，特别是在内存安全和数据竞争的避免上。Rust 的所有权系统和线程间通信方式为高效、并发安全的程序提供了强大的支持。通过 <code>std::thread</code> 创建线程、<code>mpsc::channel</code> 实现通信以及 <code>Arc</code> 和 <code>Mutex</code> 共享数据，Rust 提供了丰富的工具来应对多线程编程中的挑战。</p>
<h2 id="课后作业1"><a href="#课后作业1" class="headerlink" title="课后作业1"></a>课后作业1</h2><p>实现多线程文件处理器</p>
<h3 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a>任务描述</h3><ul>
<li>编写一个文件处理器，它从一个通道 <code>channel</code> 中接受文件路径，并在线程池中处理这些文件</li>
<li>文件处理的具体任务可以是读取文件内容并打印到控制台。</li>
<li>你需要使用 <code>rust</code> 的带缓冲区的 <code>channel</code> 来控制并发线程的数量，从而限制处理的文件数量</li>
</ul>
<h3 id="具体要求"><a href="#具体要求" class="headerlink" title="具体要求"></a>具体要求</h3><ul>
<li>文件处理任务</li>
<li>定义一个函数 <code>process_file</code> 该函数接受一个文件路径，读取文件内容，并降内容打印到控制台</li>
</ul>
<h3 id="多线程控制"><a href="#多线程控制" class="headerlink" title="多线程控制"></a>多线程控制</h3><ul>
<li>创建一个带缓冲区的  <code>channel</code> ，用于在主线程和工作线程之间传递文件路径</li>
<li>使用多线程来实现文件处理的并发性，限制线程的补发数量（例如：最多同时处理4个文件）</li>
</ul>
<h3 id="主线程作为生产者"><a href="#主线程作为生产者" class="headerlink" title="主线程作为生产者"></a>主线程作为生产者</h3><ul>
<li>主线程负责向通道发送文件路径</li>
</ul>
<h3 id="工作线程作为消费者"><a href="#工作线程作为消费者" class="headerlink" title="工作线程作为消费者"></a>工作线程作为消费者</h3><ul>
<li>创建多个工作线程，每个线程从通道中接受文件路径，并调用 <code>process_file</code> 函数来处理文件</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;Read&#125;;</span><br><span class="line"><span class="keyword">use</span> std::sync::&#123;mpsc, Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MAX_CONCURRENT_THREADS: <span class="type">usize</span> = <span class="number">4</span>; <span class="comment">// 限制最多并发线程数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件路径验证函数</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">validate_file_path</span>(file_path: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    Path::<span class="title function_ invoke__">new</span>(file_path).<span class="title function_ invoke__">exists</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件处理任务</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">process_file</span>(file_path: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> !<span class="title function_ invoke__">validate_file_path</span>(&amp;file_path) &#123;</span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;File not found: &#123;&#125;&quot;</span>, file_path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> File::<span class="title function_ invoke__">open</span>(&amp;file_path) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(<span class="keyword">mut</span> file) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">            <span class="keyword">match</span> file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Content of &#123;&#125;:\n&#123;&#125;&quot;</span>, file_path, contents),</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">eprintln!</span>(<span class="string">&quot;Failed to read file &#123;&#125;: &#123;&#125;&quot;</span>, file_path, e),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">eprintln!</span>(<span class="string">&quot;Failed to open file &#123;&#125;: &#123;&#125;&quot;</span>, file_path, e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 打印当前工作目录</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">current_dir</span> = env::<span class="title function_ invoke__">current_dir</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Current working directory: &#123;&#125;&quot;</span>, current_dir.<span class="title function_ invoke__">display</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个带缓冲区的通道，限制最大并发线程数</span></span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">sync_channel</span>(MAX_CONCURRENT_THREADS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Arc 和 Mutex 来共享 Receiver 给多个线程</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rx</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(rx));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动线程池</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..MAX_CONCURRENT_THREADS &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">rx</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;rx);</span><br><span class="line">        thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="comment">// 锁定并接收文件路径</span></span><br><span class="line">                <span class="keyword">let</span> <span class="variable">rx</span> = rx.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                <span class="keyword">match</span> rx.<span class="title function_ invoke__">recv</span>() &#123;</span><br><span class="line">                    <span class="title function_ invoke__">Ok</span>(file_path) =&gt; &#123;</span><br><span class="line">                        <span class="title function_ invoke__">process_file</span>(file_path); <span class="comment">// 处理文件</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="keyword">break</span>, <span class="comment">// 当通道关闭时，退出线程</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程作为生产者，模拟添加任务</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file_paths</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        <span class="string">&quot;file/file1.txt&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        <span class="string">&quot;file/file2.html&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">file_path</span> <span class="keyword">in</span> file_paths &#123;</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(file_path).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 向通道发送文件路径</span></span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">100</span>)); <span class="comment">// 模拟任务提交的延迟</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待一段时间，确保所有线程完成任务</span></span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="课后作业2"><a href="#课后作业2" class="headerlink" title="课后作业2"></a>课后作业2</h2><p>使用Channel实现程序的优雅停止</p>
<h3 id="任务描述-1"><a href="#任务描述-1" class="headerlink" title="任务描述"></a>任务描述</h3><ul>
<li>编写一个多线程程序，该程序会创建多个工作线程，持续处理任务。在接收到停止信号时，所有工作线程应该优雅地停止工作，并确保所有未完成的任务都被处理完毕。</li>
<li>你将使用Rust的channel来实现任务的调度和优雅停止机制。</li>
</ul>
<h3 id="具体要求-1"><a href="#具体要求-1" class="headerlink" title="具体要求"></a>具体要求</h3><ul>
<li>工作线程<ul>
<li>创建一个工作线程池，工作线程从通道接收任务并处理。</li>
<li>工作线程应能够响应停止信号，并在完成当前任务后优推地退出。</li>
</ul>
</li>
</ul>
<h3 id="任务结构"><a href="#任务结构" class="headerlink" title="任务结构"></a>任务结构</h3><ul>
<li>任务可以是简单的打印操作，模拟一些耗时工作，例如打印任务ID并暂停一段时间。</li>
</ul>
<h3 id="优雅停止"><a href="#优雅停止" class="headerlink" title="优雅停止"></a>优雅停止</h3><ul>
<li>通过发送一个特殊的停止信号，通知所有工作线程停止接收新的任务，并在完成当前任务后退出。</li>
<li>确保所有已接收的任务都被处理完毕。</li>
</ul>
<h3 id="主线程控制"><a href="#主线程控制" class="headerlink" title="主线程控制:"></a>主线程控制:</h3><ul>
<li>主线程应当能够发送任务，也能够在适当的时候发送停止信号，触发工作线程的优雅停止。</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MAX_CONCURRENT_THREADS: <span class="type">usize</span> = <span class="number">4</span>; <span class="comment">// 限制线程池大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务结构，简单的打印任务</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">process_task</span>(task_id: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Processing task: &#123;&#125;&quot;</span>, task_id);</span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>)); <span class="comment">// 模拟任务处理</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Task &#123;&#125; completed&quot;</span>, task_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建一个通道用于任务传递</span></span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Arc和Mutex共享接收端rx给多个线程</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rx</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(rx));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动工作线程池</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..MAX_CONCURRENT_THREADS &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">rx</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;rx);</span><br><span class="line">        thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="comment">// 锁定通道接收任务</span></span><br><span class="line">                <span class="keyword">let</span> <span class="variable">rx</span> = rx.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                <span class="keyword">match</span> rx.<span class="title function_ invoke__">recv</span>() &#123;</span><br><span class="line">                    <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">Some</span>(task_id)) =&gt; &#123;</span><br><span class="line">                        <span class="title function_ invoke__">process_task</span>(task_id); <span class="comment">// 处理任务</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="title function_ invoke__">Ok</span>(<span class="literal">None</span>) =&gt; &#123;</span><br><span class="line">                        <span class="comment">// 收到停止信号，退出线程</span></span><br><span class="line">                        <span class="built_in">println!</span>(<span class="string">&quot;Thread is stopping gracefully.&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="title function_ invoke__">Err</span>(_) =&gt; &#123;</span><br><span class="line">                        <span class="comment">// 通道关闭，退出线程</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程发送任务</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(<span class="title function_ invoke__">Some</span>(i)).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 发送任务</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Task &#123;&#125; sent&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">500</span>)); <span class="comment">// 模拟任务提交延迟</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送停止信号给所有线程</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Sending stop signal to all threads...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..MAX_CONCURRENT_THREADS &#123;</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(<span class="literal">None</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保主线程等待所有任务完成</span></span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">5</span>)); <span class="comment">// 等待所有任务完成</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;All tasks are completed. Program exiting.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Rust学习笔记</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust进阶：test 测试</title>
    <url>/2024/11/24/Rust%E8%BF%9B%E9%98%B6%EF%BC%9Atest%20%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>Rust 提供了内置的测试框架，可以让你方便地编写单元测试、集成测试以及性能测试。以下是一些 Rust 中进行测试的进阶内容，帮助你更好地掌握测试功能。</p>
<h3 id="1-单元测试-Unit-Tests"><a href="#1-单元测试-Unit-Tests" class="headerlink" title="1. 单元测试 (Unit Tests)"></a>1. 单元测试 (Unit Tests)</h3><p>Rust 中的单元测试通常写在与实现代码相同的文件中，使用 <code>#[cfg(test)]</code> 和 <code>#[test]</code> 注解。单元测试的基本写法如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">test_add</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">add</span>(<span class="number">2</span>, <span class="number">3</span>), <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>#[cfg(test)]</code> 用于指定代码仅在测试环境下编译。</li>
<li><code>#[test]</code> 用于标记一个函数为测试函数。</li>
<li><code>assert_eq!</code> 是一个宏，用来验证表达式是否相等。</li>
</ul>
<h3 id="2-集成测试-Integration-Tests"><a href="#2-集成测试-Integration-Tests" class="headerlink" title="2. 集成测试 (Integration Tests)"></a>2. 集成测试 (Integration Tests)</h3><p>集成测试通常位于 <code>tests</code> 目录下，单独作为测试模块存在。你可以创建一个 <code>tests</code> 文件夹，并将测试文件放在其中。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tests/integration_test.rs</span></span><br><span class="line"><span class="keyword">use</span> my_crate::add;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test_add_integration</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">add</span>(<span class="number">5</span>, <span class="number">6</span>), <span class="number">11</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以通过运行 <code>cargo test</code> 来执行集成测试。</p>
<h3 id="3-运行测试"><a href="#3-运行测试" class="headerlink" title="3. 运行测试"></a>3. 运行测试</h3><p>你可以通过以下命令运行测试：</p>
<ul>
<li><code>cargo test</code>：运行所有测试（包括单元测试和集成测试）。</li>
<li><code>cargo test test_add</code>：只运行名为 <code>test_add</code> 的测试。</li>
<li><code>cargo test -- --nocapture</code>：显示标准输出内容。</li>
</ul>
<h3 id="4-测试的生命周期"><a href="#4-测试的生命周期" class="headerlink" title="4. 测试的生命周期"></a>4. 测试的生命周期</h3><p>Rust 测试框架会自动管理测试的生命周期。每个测试函数默认是独立运行的，并且会在测试之前和之后自动进行初始化和清理工作。</p>
<p>如果需要自定义初始化或清理逻辑，可以使用 <code>#[test]</code> 函数中的 <code>setup</code> 和 <code>teardown</code>。Rust 没有内置的 <code>setup</code> 和 <code>teardown</code>，但可以通过函数来模拟。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TestContext</span> &#123;</span><br><span class="line">    data: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">TestContext</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">setup</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        TestContext &#123;</span><br><span class="line">            data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Test data&quot;</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">teardown</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 清理资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">test_with_setup</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">context</span> = TestContext::<span class="title function_ invoke__">setup</span>();</span><br><span class="line">        <span class="built_in">assert_eq!</span>(context.data, <span class="string">&quot;Test data&quot;</span>);</span><br><span class="line">        <span class="comment">// 自动调用 teardown</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-异常测试"><a href="#5-异常测试" class="headerlink" title="5. 异常测试"></a>5. 异常测试</h3><p>Rust 的 <code>Result</code> 类型用于表示可能会失败的操作。如果你想测试错误分支，可以使用 <code>assert!(result.is_err())</code> 或者 <code>assert_eq!(result.unwrap_err(), expected_error)</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test_result_error</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span>: <span class="type">Result</span>&lt;<span class="type">i32</span>, &amp;<span class="type">str</span>&gt; = <span class="title function_ invoke__">Err</span>(<span class="string">&quot;An error occurred&quot;</span>);</span><br><span class="line">    <span class="built_in">assert!</span>(result.<span class="title function_ invoke__">is_err</span>());</span><br><span class="line">    <span class="built_in">assert_eq!</span>(result.<span class="title function_ invoke__">unwrap_err</span>(), <span class="string">&quot;An error occurred&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-性能测试"><a href="#6-性能测试" class="headerlink" title="6. 性能测试"></a>6. 性能测试</h3><p>Rust 提供了 <code>#[bench]</code> 注解来进行基准测试。基准测试要求启用 nightly 版本的 Rust，并且通过 <code>test</code> crate 来进行标记。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![feature(test)]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> test::Bencher;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[bench]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">bench_add</span>(b: &amp;<span class="keyword">mut</span> Bencher) &#123;</span><br><span class="line">    b.<span class="title function_ invoke__">iter</span>(|| <span class="title function_ invoke__">add</span>(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行基准测试时，使用 <code>cargo bench</code>。</p>
<h3 id="7-使用-Mocking"><a href="#7-使用-Mocking" class="headerlink" title="7. 使用 Mocking"></a>7. 使用 Mocking</h3><p>如果测试涉及到外部依赖（如数据库、HTTP 请求等），可以使用 mocking 框架来模拟这些依赖。<code>mockall</code> 和 <code>mockito</code> 是常用的 Rust mocking 库。</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dev-dependencies]</span></span><br><span class="line"><span class="attr">mockall</span> = <span class="string">&quot;0.10&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后在测试中使用它们来模拟函数调用。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> mockall::&#123;mock, predicate::*&#125;;</span><br><span class="line"></span><br><span class="line">mock! &#123;</span><br><span class="line">    <span class="keyword">pub</span> Network &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">fetch_data</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test_mocking</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">mock</span> = MockNetwork::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    mock.<span class="title function_ invoke__">expect_fetch_data</span>().<span class="title function_ invoke__">return_const</span>(<span class="string">&quot;mocked data&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">assert_eq!</span>(mock.<span class="title function_ invoke__">fetch_data</span>(), <span class="string">&quot;mocked data&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-并发测试"><a href="#8-并发测试" class="headerlink" title="8. 并发测试"></a>8. 并发测试</h3><p>Rust 的并发测试可以通过 <code>tokio</code> 或 <code>async-std</code> 库来支持异步操作。你可以利用 <code>#[tokio::test]</code> 或 <code>#[async_std::test]</code> 来执行异步测试。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[tokio::test]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">test_async</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">async_fn</span>().<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(result, <span class="number">42</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">async_fn</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="number">42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-组合测试"><a href="#9-组合测试" class="headerlink" title="9. 组合测试"></a>9. 组合测试</h3><p>Rust 提供了对组合测试的支持，你可以将多个测试组合成一个大的测试模块，或者在不同的测试模块之间共享数据。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">test_one</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">add</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">test_two</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">add</span>(<span class="number">3</span>, <span class="number">4</span>), <span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">test_combined</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">test_one</span>();</span><br><span class="line">        <span class="title function_ invoke__">test_two</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><ul>
<li><a href="https://crates.io/crates/is_lolo_crate_v1">https://crates.io/crates/is_lolo_crate_v1</a></li>
<li>github: <a href="https://github.com/isLiuyinghao/my_crate">https://github.com/isLiuyinghao/my_crate</a></li>
</ul>
]]></content>
      <categories>
        <category>Rust学习笔记</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>基础 - 变量和可变类型</title>
    <url>/2024/08/21/%E5%8F%98%E9%87%8F%E5%92%8C%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="可变变量和不可变变量-Mutable-Immutable"><a href="#可变变量和不可变变量-Mutable-Immutable" class="headerlink" title="可变变量和不可变变量(Mutable&amp;Immutable)"></a>可变变量和不可变变量(Mutable&amp;Immutable)</h1><p>Rust的变量默认是不可改变的(immutable)，如果我们想改变变量的值，就需要声明可变变量(mutable)</p>
<h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><ul>
<li>不可变变量  <figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">let <span class="attr">x</span>= <span class="number">5</span> </span><br></pre></td></tr></table></figure></li>
<li>可变变量  <figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">let mut <span class="attr">x</span> = <span class="number">5</span><span class="comment">;</span></span><br><span class="line"><span class="attr">x</span> = <span class="number">6</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>可变变量是是否用 <code>mut</code>关键字进行声明</p>
</blockquote>
<h3 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><p>对不可变变量进行赋值会怎么样？ <span class="hide-inline"><button type="button" class="hide-button" style="background-color: #FF7242;color: #fff">查看答案
  </button><span class="hide-content">`cannot assign twice to immutable variable`</span></span></p>
<p>对！就是报错<br><img src="/../img/%E5%8F%98%E9%87%8F%E5%92%8C%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B01.png" alt="报错信息"></p>
<h1 id="常量（Constants）"><a href="#常量（Constants）" class="headerlink" title="常量（Constants）"></a>常量（Constants）</h1><blockquote>
<p>使用const关键字来定义一个常量。定义常量时需要明确的指定常量的数据类型。</p>
</blockquote>
<h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><ul>
<li>必须<strong>显示</strong>指定数据类型</li>
<li>常量名<strong>一般使用大写字母</strong>，否则编译器会报Warning</li>
<li>必须使用常量表达式进行赋值，即必须是编译期能计算出的值。</li>
<li>常量<strong>不支持</strong>重定义（遮蔽），这和变量是不同的。</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">// 常量声明</span><br><span class="line">const NUM: <span class="attr">i32</span> = <span class="number">5</span><span class="comment">;</span></span><br><span class="line">println!(&quot;constants values is &#123;&#125;&quot;, NUM)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h2 id="不可变变量和常量的区别？"><a href="#不可变变量和常量的区别？" class="headerlink" title="不可变变量和常量的区别？"></a>不可变变量和常量的区别？</h2><ul>
<li>关键字<ul>
<li>常量使用<code>const</code>声明，不可变变量使用<code>let</code></li>
</ul>
</li>
<li>赋值时机<ul>
<li>常量在<strong>编译期</strong>就确定了值，无法再运行时改变。不可变变量直到<strong>运行期</strong>才能确定下来</li>
</ul>
</li>
<li>能否改变<ul>
<li>常量<strong>不可以</strong>修改，不可变变量可以通过<strong>shadowing</strong>来修改</li>
</ul>
</li>
<li>声明<ul>
<li>常量<strong>必须</strong>声明类型，不可变变量<strong>不需要</strong></li>
</ul>
</li>
<li>命名<ul>
<li>常量必须使用<strong>大写字母</strong>，不可变变量不需要</li>
</ul>
</li>
</ul>
<h1 id="静态变量（Static）"><a href="#静态变量（Static）" class="headerlink" title="静态变量（Static）"></a>静态变量（Static）</h1><ul>
<li>使用<code>static</code>关键字声明，并在编译时分配内存，且在程序运行期间一直存在；</li>
<li>静态变量可以在整个程序中共享，且可以再多个线程间共享；</li>
<li>静态变量的值在运行期间不会改变，因此它们通常用于存储程序的全局状态</li>
</ul>
<h2 id="与常量特性进行对比"><a href="#与常量特性进行对比" class="headerlink" title="与常量特性进行对比"></a>与常量特性进行对比</h2><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>常量 (<code>const</code>)</strong></th>
<th><strong>静态变量 (<code>static</code>)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>定义方式</strong></td>
<td>使用 <code>const</code> 关键字</td>
<td>使用 <code>static</code> 关键字</td>
</tr>
<tr>
<td><strong>命名要求</strong></td>
<td>名称要求使用大写 (不强制，但建议)</td>
<td>名称要求使用大写 (不强制，但建议)</td>
</tr>
<tr>
<td><strong>类型要求</strong></td>
<td>必须明确指定类型</td>
<td>必须明确指定类型</td>
</tr>
<tr>
<td><strong>赋值方式</strong></td>
<td>必须使用常量表达式</td>
<td>必须使用常量表达式</td>
</tr>
<tr>
<td><strong>可变性</strong></td>
<td>不可变</td>
<td>默认不可变，但可以通过 <code>mut</code> 关键字定义为可变</td>
</tr>
<tr>
<td><strong>编译时行为</strong></td>
<td>在编译时被内联</td>
<td>在整个程序中只有一个实例，引用指向同一地址</td>
</tr>
<tr>
<td><strong>遮蔽</strong></td>
<td>不支持遮蔽</td>
<td>不支持遮蔽</td>
</tr>
<tr>
<td><strong>生命周期</strong></td>
<td>在程序运行的整个生命周期中都有效</td>
<td>在程序运行的整个生命周期中都有效</td>
</tr>
</tbody></table>
<blockquote>
<p>常量在编译时被内联，但静态变量不会。在整个程序中静态变量只有一个实例，所有引用都指向一个地址</p>
</blockquote>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">// 常量的内联</span><br><span class="line">const A: <span class="attr">i32</span> = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">static B: <span class="attr">i32</span> = <span class="number">2</span><span class="comment">;</span></span><br><span class="line">fn main () &#123;</span><br><span class="line">	println!&#123;&quot;const <span class="attr">value</span> = &#123;&#125;<span class="string">&quot;, A&#125;;</span></span><br><span class="line"><span class="string">	//在编译期间，常量的访问会被替换成常量的值（内联）</span></span><br><span class="line"><span class="string">	//所以上面的代码会被编译成：println!&#123;&quot;</span>const value = &#123;&#125;<span class="string">&quot;, 1&#125;;</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  // 但是静态变量的访问指向的是这个变量所对应的内存地址</span></span><br><span class="line"><span class="string">  println!&#123;&quot;</span>static value = &#123;&#125;<span class="string">&quot;, B&#125;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可变性：常量不可变，静态变量默认不可变，但可以通过mut关键字定义为可变</p>
</blockquote>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">// 声明一个可变的静态变量</span><br><span class="line">static mut NUM: <span class="attr">i32</span> = <span class="number">30</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// 静态变量是全局的，多线程共享的。对它的值的修改不是线程安全的，需要把这段代码放入unsafe代码块中执行。否则编译期间会报错。这里只是举例</span><br><span class="line">unsafe &#123;</span><br><span class="line">	NUM += 1<span class="comment">;</span></span><br><span class="line">	println!(&quot;the static value is &#123;&#125;&quot;, NUM)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="作用域和遮蔽-variable-shadowing"><a href="#作用域和遮蔽-variable-shadowing" class="headerlink" title="作用域和遮蔽 (variable shadowing)"></a>作用域和遮蔽 (variable shadowing)</h2><p>变量绑定有一个作用域(scope)，它被限定只在一个代码块(block)中生存(live)。代码块是一个被包围的语句集合。另外也允许变量遮蔽(variable shadowing)。</p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">fn shadowing() &#123;</span><br><span class="line">    let test: <span class="attr">i32</span> = <span class="number">5</span><span class="comment">;</span></span><br><span class="line">    println!(&quot;常量 test &#123;&#125;&quot;, test)<span class="comment">;</span></span><br><span class="line">    let <span class="attr">test</span> = <span class="number">6</span><span class="comment">;</span></span><br><span class="line">    println!(&quot;遮蔽后：常量 test &#123;&#125;&quot;, test)<span class="comment">;</span></span><br><span class="line">    &#123;</span><br><span class="line">     println!(&quot;小作用域中-遮蔽后常量 test &#123;&#125;&quot;, test)<span class="comment">;</span></span><br><span class="line">     let <span class="attr">test</span> = <span class="number">100</span><span class="comment">;</span></span><br><span class="line">     println!(&quot;小作用域遮蔽后：常量 test &#123;&#125;&quot;, test)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;最终常量 test &#123;&#125;&quot;, test)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">常量 test 5</span><br><span class="line">遮蔽后：常量 test 6</span><br><span class="line">小作用域中-遮蔽后常量 test 6</span><br><span class="line">小作用域遮蔽后：常量 test 100</span><br><span class="line">最终常量 test 6</span><br></pre></td></tr></table></figure>

<p>根据上面的测试，我们得到以下的结果：</p>
<ol>
<li>在当前作用域下，遮蔽后的值就是当前作用域中访问这个变量得到的最终值</li>
<li>遮蔽一个比当前作用域声明周期更长的变量的时候，遮蔽的作用范围只在当前的作用域内，超出作用域的变量的值还是遮蔽之前的值</li>
</ol>
]]></content>
      <categories>
        <category>Rust学习笔记</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>环境变量不被注册？</title>
    <url>/2024/08/20/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8D%E8%A2%AB%E6%B3%A8%E5%86%8C%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="环境变量问题"><a href="#环境变量问题" class="headerlink" title="环境变量问题"></a>环境变量问题</h1><p>相信大家很容易遇到</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xxxx : 无法将“xxxx”项识别为 cmdlet、函数、脚本</span><br><span class="line">文件或可运行程序的名称。请检查名称的拼写，如果包括路径，</span><br><span class="line">请确保路径正确，然后再试一次。</span><br></pre></td></tr></table></figure>
<h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><p>记得用管理员权限进行运行:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set-ExecutionPolicy RemoteSigned</span><br></pre></td></tr></table></figure>
<p>后输入: A</p>
<p>接着输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">get-ExecutionPolicy </span><br></pre></td></tr></table></figure>
<p>看见有：<br>RemoteSigned 输出即可</p>
]]></content>
      <categories>
        <category>日常开发</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
</search>
